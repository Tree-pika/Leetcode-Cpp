* it++ 需要产生一个临时对象来保存旧值。
  * ++it (前置自增 Pre-increment)先将迭代器向前移动一步。然后返回移动后的迭代器本身的引用。
* 想要利用迭代器删除所有符合条件的：
    ```cpp
    for (auto it = graph[from].begin(); it != graph[from].end(); /* 空 */) {
        if (it->to == to) {
            it = graph[from].erase(it); // erase 返回下一个有效的迭代器
        } else {
            ++it; // 只有没删除时才手动自增
        }
    }
    ```
# vector
* vector是`push_back()`，queue/stack是`push()`
* `push_back()`需要传构造好的对象，`emplace_back()`直接传构造对象的参数即可，会原地构造一个对象出来
```cpp
    // 方法 A: 配合 push_back (推荐，利用 reserve 避免多次内存分配)
    path.reserve(10);
    path.push_back(5); 

    // 方法 B: 如果想直接用下标，必须用 resize
    path.resize(10); // 现在 size 是 10 了，元素默认初始化为 0
    path[0] = 5;     // 安全
```
* operator[]（下标访问）只能访问 0 到 size() - 1 范围内的元素。
* reserve是预留容量capacity，size还是0
* 