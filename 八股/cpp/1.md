## 1\. 四种 Cast

C++ 中主要有四种类型转换：`static_cast`、`dynamic_cast`、`const_cast` 及 `reinterpret_cast`。

  * **`static_cast`**

      * 用于基本类型（如 `int`, `float` 等）的转换。
      * 也可用于父类与子类之间的静态转换（无运行时检查）。

  * **`dynamic_cast`**

      * 主要用于父类与子类的转换。
      * **特点**：相比 `static_cast`，它拥有**运行时类型检查**。如果转换不安全（无法转换），则会返回 `nullptr`。

  * **`const_cast`**

      * 主要用于改变常量属性，即将一个常量改为非常量。
      * **场景**：一般配合模板使用（因为模板可能会把一个 `T` 传为 `const T`）。
      * **注意**：直接对存放在常量区的变量执行 `const_cast` 是 **UB (Undefined Behavior, 未定义行为)**。

    <!-- end list -->

    ```cpp
    const int a = 1;
    // 下面的操作是一个 UB 行为
    // const_cast<int&>(a) = 2; 
    ```

  * **`reinterpret_cast`**

      * 强制类型转换，不进行类型检查。
      * 理论上可以将任意类型转换为任意类型（如整数转指针），使用时需要非常谨慎。

-----

## 2\. 野指针问题

### 成因

1.  **内存释放**：指针指向的区域已经被 `delete` 或 `free`，但指针未置空。
2.  **作用域结束**：指针指向的是一个局部变量，变量脱离作用域后被释放。
3.  **共享指针**：多个指针指向同一个变量，对其中一个指针执行 `delete` 操作后，其他指针变为野指针。

### 如何避免

  * 使用 C++11 引入的**智能指针**（Smart Pointers）。

### 如何检测

  * 通常使用第三方工具（如 Valgrind）来检测内存泄漏。

-----

## 3\. 左右值及左右值引用

  * **简单理解**：
      * **左值 (L-value)**：能够放在等号左端的（有持久存储地址）。
      * **右值 (R-value)**：只能放在等号右端的（临时对象，字面量）。
  * **目的**：引入右值引用的主要目的是为了实现**移动语义 (Move Semantics)**，减少深拷贝的开销。
  * *注：C++17 对值类别（Value Categories）有更详细的分类（glvalue, prvalue, xvalue），建议深入查阅。*

-----

## 4\. delete & delete[]

  * 需要与 `new` 和 `new[]` 配对使用：
      * `new` 创建单个对象 $\rightarrow$ 使用 `delete` 释放。
      * `new[]` 创建数组 $\rightarrow$ 使用 `delete[]` 释放。

-----

## 5\. 智能指针

C++11 引入了三种主要的智能指针：

1.  **`shared_ptr`**

      * **特点**：允许多个指针指向同一个对象。
      * **原理**：内部维护一个**引用计数**。当有指针指向对象时计数 +1，脱离作用域时计数 -1。当计数归零时，自动释放对象。
      * **优势**：避免了手动释放内存导致的野指针问题。

2.  **`unique_ptr`**

      * **特点**：独占所有权，同一时间只允许一个指针访问变量。
      * **操作**：不支持复制（Copy），只支持移动（Move）或所有权转移。转移后原指针失效。

3.  **`weak_ptr`**

      * **目的**：解决 `shared_ptr` 可能出现的**循环引用 (Circular Reference)** 问题。
      * **循环引用场景**：Class A 持有 B 的 shared\_ptr，Class B 持有 A 的 shared\_ptr。两者析构时互相等待对方释放，导致计数无法归零，产生内存泄漏。
      * **原理**：`weak_ptr` 指向 `shared_ptr` 的资源，但不增加引用计数。其生命周期跟随 `shared_ptr`，当对象释放时，`weak_ptr` 自动失效。

-----

## 6\. 关键字辨析 (volatile / const / mutable / explicit)

  * **`volatile`**

      * 表示变量可能会被编译器未知的方式（如硬件中断、多线程）修改。
      * **作用**：告诉编译器**不要对该变量进行优化**，每次操作均需直接从内存读取，而不是使用寄存器中的缓存值。
      * **场景**：嵌入式、驱动开发、硬件寄存器映射。

  * **`const`**

      * 定义常量，表示数据不可修改。

  * **`mutable`**

      * 与 `const` 相对，表示变量是“可变的”。
      * **场景**：用于被 `const` 修饰的成员函数中，允许修改特定的成员变量。

    <!-- end list -->

    ```cpp
    class A {
    public:
        A() : m_a(0), m_b(0) {}
        // const 函数承诺不修改成员变量
        void func() const {
            // m_a = 1;  // Error: 表达式必须是可修改的左值
            m_b = 1;     // OK: m_b 被 mutable 修饰
        }
    private:
        int m_a;
        mutable int m_b;
    };
    ```

  * **`explicit`**

      * 禁止构造函数发生**隐式类型转换**。
      * **例子**：若构造函数接受 `int`，输入 `float(2.0)` 可能会被隐式转换为 `int(2)`。使用 `explicit` 可避免此类意外调用。

  * **补充：`nullptr` vs `NULL`**

      * C 语言中 `#define NULL 0`，这导致 `NULL` 在传参时可能被解析为整型 `0` 而非指针。
      * C++11 引入 `nullptr`（空指针常量，类型为 `std::nullptr_t`），解决了类型二义性问题。

-----

## 7\. atomic

  * **功能**：用于多线程开发，保证操作的**原子性**（即操作不可分割，不会被线程调度打断）。
  * **用途**：避免多线程竞争导致的数据不一致，通常比互斥锁（Mutex）更轻量级。

-----

## 8\. std::forward 与完美转发

**完美转发 (Perfect Forwarding)** 通常应用于模板编程，目标是保持参数的左值/右值属性不变地传递给下一个函数。

### 前置概念

1.  **万能引用 (Universal Reference)**：在模板中，`T&&` 可以匹配任何类型的输入（左值或右值）。
      * 输入左值 $\rightarrow$ 匹配为 `T&`
      * 输入右值 $\rightarrow$ 匹配为 `T` (即 `T&&`)
2.  **引用折叠 (Reference Collapsing)**：C++ 不允许引用的引用，因此遵循以下规则：
      * `&` + `&` $\rightarrow$ `&`
      * `&` + `&&` $\rightarrow$ `&`
      * `&&` + `&` $\rightarrow$ `&`
      * `&&` + `&&` $\rightarrow$ `&&`
      * **总结**：只要遇到左值引用 `&`，结果就是左值引用；只有全是右值引用 `&&`，结果才是右值引用。

### std::forward 的作用

配合 `T&&` 使用，当传入的是左值时，它将参数转化为左值；当传入的是右值时，它将参数转化为右值，从而实现“完美转发”。

-----

## 9\. `std::thread` 线程安全问题

  * **本身安全性**：`std::thread` 对象本身是轻量级的句柄，对其自身的管理（如移动、赋值）符合标准库类型的基本安全规则。
  * **业务安全性**：`std::thread` **并不保证**其执行的代码块内部访问共享数据的安全性。
  * **如何保证安全**：必须使用同步机制。
      * **互斥锁**：`std::mutex` 配合 `std::lock_guard` 或 `std::unique_lock`（RAII 风格上锁）。
      * **原子操作**：`std::atomic`（用于计数器、标志位等）。
      * **条件变量**：`std::condition_variable`（用于线程间通信和等待）。

## 10\. `memory_order` (内存序)

这是 C++11 引入原子操作时为了榨干 CPU 性能而提供的底层控制，主要用于无锁编程（Lock-free）。

  * **场景**：多线程对原子变量进行操作时，为了优化性能，编译器和 CPU 可能会对指令进行重排。`memory_order` 用于约束这种重排。
  * **常见类型**：
      * `memory_order_relaxed`：最宽松，只保证当前操作是原子的，不保证顺序（指令可重排）。
      * `memory_order_acquire` / `memory_order_release`：**获取/释放语义**。通常成对使用，保证 Release 之前的写操作对 Acquire 之后的读操作可见（建立 Synchronizes-with 关系）。
      * `memory_order_seq_cst`：**顺序一致性**（默认）。最严格，保证所有线程看到的操作顺序是一致的，性能开销最大。

## 11\. 虚函数表 (vtable)

  * **存放位置**：一般存放在只读数据段 (**`.rodata`**)，因为虚表在编译/链接期生成后就不再改变。
  * **管理方式**：
      * **每个类一份**：虚表是属于类的（Per Class），不是属于对象的。所有该类的对象共享同一个虚表。
      * **虚表指针 (vptr)**：编译器会在有虚函数的对象头部（通常是开头）插入一个隐藏指针 `vptr`，指向该类的 vtable。
  * **多继承情况**：
      * 如果一个类继承自多个带有虚函数的父类，它会拥有**多个 vtable**（或者说一个包含多个部分的复杂 vtable），对象内部也会有**多个 vptr**，分别指向对应父类视角的虚表部分，以支持不同父类指针的正确调用。

## 12\. 二进制文件的分区

一个标准的可执行文件（如 ELF 格式）通常包含以下段：

  * **`.text`**：代码段，存放编译后的机器指令（只读）。
  * **`.rodata`**：只读数据段，存放常量（const 变量）、字符串常量、虚函数表。
  * **`.data`**：数据段，存放**已初始化**的全局变量和静态变量。
  * **`.bss`**：Block Started by Symbol，存放**未初始化**的全局变量和静态变量（程序启动时自动清零）。
  * **Stack**：栈，局部变量。
  * **Heap**：堆，动态分配内存。

## 13\. 大小端代码分析

```cpp
int val = 0x1234; 
char* p = (char*) &val; 
cout << (int)*(p+1) << endl;
```

  * **原理**：考察**大小端模式 (Endianness)**。
  * 假设 `int` 为 4 字节，`0x1234` 补全为 `0x00001234`。
  * **小端模式 (Little Endian)**（常见于 x86/x64）：低位字节存低地址。
      * 内存布局：`34 12 00 00`
      * `p` 指向 `34`，`p+1` 指向 `12` (十六进制)。
      * `0x12` 转换为十进制输出为 **18**。
  * **大端模式 (Big Endian)**（网络序）：高位字节存低地址。
      * 内存布局：`00 00 12 34`
      * `p+1` 指向 `00`。
      * 输出为 **0**。
  * **结论**：在常见的 PC 上（小端）输出 18。

## 14\. C 与 C++ Struct 的区别

  * **C 语言**：`struct` 只是聚合数据，内部不能有函数（只能放函数指针），没有 `this` 指针，没有访问权限控制（默认公开）。声明变量时通常需要写 `struct MyData d;`（除非 typedef）。
  * **C++**：`struct` 与 `class` **几乎完全一样**。
      * **唯一区别**：`struct` 的成员默认权限是 `public`，继承默认也是 `public`；而 `class` 默认是 `private`。
      * C++ 的 struct 可以包含函数、构造函数、虚函数、继承等。

## 15\. C++ 新特性 (11/14/17)

  * **C++11 (大版本)**：
      * `auto` / `decltype` (类型推导)
      * `nullptr`
      * 智能指针 (`shared_ptr`, `unique_ptr`)
      * Lambda 表达式
      * 右值引用与移动语义 (`std::move`)
      * `std::thread`, `std::mutex`
  * **C++14 (完善版)**：
      * 泛型 Lambda (`auto` 参数)
      * `std::make_unique`
      * 放宽 `constexpr` 限制
  * **C++17 (大版本)**：
      * **结构化绑定** (Structured Binding)：`auto [x, y] = pair;`
      * `std::string_view` (轻量级字符串切片，无拷贝)
      * `std::optional`, `std::variant`, `std::any`
      * `if constexpr` (编译期 if)
      * 文件系统库 `<filesystem>`

## 16\. 内存对齐

  * **原理**：CPU 访问内存通常是按字长（word）读取的（如 4 字节或 8 字节）。对齐可以提高内存访问效率，避免跨边界读取导致的二次访问或硬件异常。
  * **规则**：
    1.  **成员对齐**：成员的偏移量必须是 `min(成员大小, pack值)` 的倍数。
    2.  **整体补齐**：结构体总大小必须是 `min(最大成员大小, pack值)` 的倍数。
  * **`#pragma pack`**：用于改变默认对齐系数。`pack(8)` 是常见默认值。

## 17\. 虚函数与模板函数

  * **结论**：模板成员函数**不能**是虚函数。
  * **原因**：
      * **虚函数表**的大小是在编译期间确定的。
      * **模板函数**只有在被调用时才会被实例化。
      * 如果允许模板是虚函数，编译器在链接前无法知道到底有多少个特化版本，因此无法确定虚表的大小和布局。

## 18\. 模板函数的实现位置

  * **位置**：通常放在**头文件 (.h / .hpp)** 中。
  * **链接逻辑**：
      * 模板不是代码，而是生成代码的规则。
      * 编译器在处理 `.cpp` 时，如果遇到模板调用，需要看到模板的**完整定义**才能实例化出对应的机器码。
      * 如果定义放在 `.cpp` 中，其他文件 include 头文件时只能看到声明，导致编译通过但链接时报错（Undefined Reference）。

## 19\. alloca / malloc / new

  * **`alloca`**：在**栈 (Stack)** 上分配内存。函数返回时自动释放，无需手动 free。速度极快，但可能导致栈溢出。**非标准 C++**（通常是编译器扩展）。
  * **`malloc`**：C 语言标准库函数。在**堆 (Heap)** 上分配。返回 `void*`，需要手动 `free`。**不调用构造函数**。
  * **`new`**：C++ 运算符。在**堆**上分配。类型安全，**自动调用构造函数**。配合 `delete` 使用。

## 20\. sizeof

  * **性质**：**编译时运算符**（除 C99 变长数组外）。
  * **功能**：计算变量或类型在内存中占用的**字节数**。
  * **注意**：`sizeof` 计算结构体时会包含**内存对齐**的填充字节。指针的 `sizeof` 永远是固定值（32位机是4，64位机是8）。

## 21\. 强符号与弱符号 (链接)

  * **强符号**：函数定义、已初始化的全局变量。
  * **弱符号**：未初始化的全局变量、`__attribute__((weak))` 修饰的符号。
  * **规则**：
    1.  不允许同名的强符号。
    2.  强符号覆盖弱符号。
    3.  若只有弱符号，选占用空间最大的。

## 22\. 哈希表 (Hash Table)

  * **实现**：数组 + 哈希函数。
  * **解决冲突**：
    1.  **拉链法 (Chaining)**：数组元素是链表（或红黑树，如 Java HashMap），冲突时挂在后面。`std::unordered_map` 通常用此法。
    2.  **开放寻址法 (Open Addressing)**：
          * 线性探测 (Linear Probing)：当前位置被占，找下一个 +1。
          * 二次探测 (Quadratic Probing)：+1, +4, +9...
          * 双重哈希 (Double Hashing)。

## 23\. Lambda 表达式

  * **本质**：编译器生成的**匿名类 (Functor)** 对象。
  * **实现**：
      * `[]` 捕获列表对应类的**成员变量**（按值捕获是拷贝，按引用捕获是引用）。
      * `()` 参数列表对应 `operator()` 的参数。
      * `{}` 函数体对应 `operator()` 的实现。

## 24\. static 的作用

1.  **修饰局部变量**：改变生命周期。存储在静态数据区，只初始化一次，直到程序结束才释放。
2.  **修饰全局变量/函数**：改变**链接属性**（可见性）。限制该符号只在**当前文件 (Translation Unit)** 可见，避免命名冲突（Internal Linkage）。
3.  **修饰类成员**：
      * **Static 变量**：属于类而不属于对象，所有对象共享。
      * **Static 函数**：没有 `this` 指针，只能访问静态成员变量。

## 25\. 数据类型范围

  * **int**: 通常 32 位，$-2^{31} \sim 2^{31}-1$ (约 $\pm 21$ 亿)。
  * **unsigned int**: $0 \sim 2^{32}-1$ (约 42 亿)。
  * **float (单精度)**: IEEE 754，32 位，有效数字约 7 位。
  * **double (双精度)**: 64 位，有效数字约 15-16 位。

## 26\. 多态的实现方式

1.  **静态多态 (编译期)**：
      * **函数重载** (Overloading)。
      * **模板** (Templates) / 泛型编程。
2.  **动态多态 (运行期)**：
      * **虚函数** (Virtual Functions) + 继承。通过虚表指针 (`vptr`) 实现动态绑定。

## 27\. EXE 执行过程与虚拟内存

  * **起始地址一样？**：是的，在虚拟地址空间中是一样的。
  * **原理**：操作系统启用了**虚拟内存**。
      * 每个进程拥有独立的虚拟地址空间（例如 32 位系统下通常是 4GB）。
      * **编译器/链接器**假设程序加载到某个固定虚拟地址（如 `0x400000`）。
      * **MMU (内存管理单元)** 和操作系统的**页表 (Page Table)** 负责将不同进程的相同虚拟地址映射到**不同的物理内存地址**。

## 28\. vector 迭代器失效

1.  **插入元素 (push\_back/insert)**：
      * 如果导致扩容（Size \> Capacity）：**所有**迭代器全部失效（因为内存搬家了）。
      * 如果没有扩容：**插入点之后**的迭代器失效。
2.  **删除元素 (erase)**：
      * **删除点之后**的迭代器失效（数据前移覆盖）。

## 29\. C++ 可调用对象

1.  **普通函数**。
2.  **函数指针**。
3.  **类成员函数指针**。
4.  **仿函数 (Functor)**：重载了 `operator()` 的类对象。
5.  **Lambda 表达式**。
   * 所以传入需要类型参数的模板时，比如`class Compare   = std::less<T>`,需要使用`decltype()`将类型从比较器对象（lambda 实例、函数对象实例）中提取出来
6.  **`std::function`**：上述类型的通用包装器。
7.  **`std::bind`** 创建的对象。