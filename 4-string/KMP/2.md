# 28
* 理解题目细节
  * 当 needle 是空字符串时，我们应当返回什么值呢？
    * 0
    * 逻辑定义： 空字符串被认为是存在于任何字符串的起始位置（哪怕 haystack 也是空的，空串也存在于空串的第 0 位）。
    * 标准库行为： 这一行为与 C 语言的 strstr() 函数以及 Java 的 indexOf() 方法保持一致。
      * `char *strstr(const char *haystack, const char *needle);`
* 滑动窗口
  * 不好
  * 因为频繁地对 std::string 进行“头部删除”和“尾部添加”操作（即模拟窗口滑动）效率较低
* "双指针"法:朴素模式匹配算法（Brute-Force, BF）
  * 外层每次更新左指针的位置
  * 内层右指针，对于固定的左指针，依次往右挪动检查是否每个字母都通配
  * 时间复杂度：$(M - N + 1) \times N \approx M \times N\rightarrow O(M \times N)$
  * 空间复杂度：$O(1)$,inplace
* KMP
# KMP
* $O(M+N)$解决子串匹配问题
* KMP：
  * 算法目的：子串匹配
    * 一定要注意目的是在母串中匹配子串，而不是计算相等前后缀
    * 这样后续用算法的方向就会对，你先想着如何转化为子串匹配问题，然后再用KMP算法加速这个过程。
    * 如果你就只是单纯计算next数组，而并不是用匹配，可能是问题的切入思路不对。
  * 加速查找方法：找已遍历过的部分是否有要查找的元素
* 前缀后缀：
  * 为了判断已遍历过的部分的前面(前缀)是否等于后面(后缀)
  * 这样可以从后缀后面一位重新开始判断，而不是回到第一位重新开始判断
* 定义：
  * 前缀 (Prefix)： 包含首字母，不包含尾字母的所有子串。
  * 后缀 (Suffix)： 包含尾字母，不包含首字母的所有子串。
  * 最长相等前后缀： 一个字符串中，前缀和后缀完全相同的最长长度。
  * 前缀表（Prefix表）：放入next数组中存储
  * 文本串haystack
  * 模式串needle
  * 我们要在文本串中找到(所有/第一个)匹配模式串的索引
* next数组：统计相等元素的数量
* 求解next数组
  * 这个过程其实就是needle和needle自身匹配的过程
  * [详细图解](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/2600821/kan-bu-dong-ni-da-wo-kmp-suan-fa-chao-qi-z1y0)
* 复杂度分析
  * 空间复杂度：我们开了一个 vector<int> next(n)。$O(N)$ —— $N$ 是 needle 的长度。
  * 时间复杂度：
    * 构建 Next 数组： 循环 i 走了 $N$ 次。虽然里面有 while 回退，但注意 j 最多只能增加 $N$ 次，所以它最多也只能减少 $N$ 次。摊还分析后是 $O(N)$。
      * 即从i=0到i=n-1，将所有循环中j减少的次数加起来 = N
      * 比如一次循环中j一直减小，减小到1，但是因为后续j的增大每次循环只能+1，所以后续j再减小时，次数为常量的(因为每次减少，值至少-1，但是最终的值又是>=1的，所以就决定了不可能再减少很多次)
    * 匹配过程： 循环 i 走了 $M$ 次。同理，j 的回退次数受限于它增加的次数。是 $O(M)$。总复杂度：$O(M + N)$。
  
# 459
* bruce solution
  * 因为子串结束位置大于中间位置的话，一定不能重复组成字符串。
  * 所以使用两层for循环,外层遍历获取子串的终止位置（子串起始位置固定到0）
  * 内层循环判断子串是否能重复构成字符串：知道了子串的大小、内容，使用字符串拼接判断即可
  * 时间复杂度：$O(N^2)$
* 利用可由重复子串组成的字符串s的特点
  * 将`s`double一下，掐头去尾，中间肯定还有个s存在
* 移动匹配
  * 如果一个字符串 $S$ 是由某个子串 $P$ 重复 $k$ 次构成的（其中 $k \ge 2$），那么这个字符串具有“周期性”。
    * 即当我们把整个字符串向左（或向右）移动 $|P|$ （子串 $P$ 的长度）个位置时，它应该和原来的字符串完全重合。
  * 可以利用双倍字符串构造法（The Double String Trick）来检测：
    * 将两个 $S$ 拼接起来，得到 $S' = S + S$。这个 $S'$ 实际上包含了 $S$ 的所有可能的“循环移位”状态。
    * 需要验证的是：是否存在一个“非平凡”的移位（即移动步数小于 $|S|$ 且大于 0），使得 $S$ 依然存在。
      * 方法：刨除 s + s 的首字符和尾字符，这样避免在s+s中搜索出原来的s(包括第一个和复制的第二个)。
    * 检测：中间是否还存在一个`s`
  * 最后，这道题就转化到了判断一个字符串中是否出现另一个字符串
    * 可以直接使用库函数`contains()`，返回类型就是`bool`
    * 但高效判断算法是KMP
* KMP
  * 延续上面的思路，用于在掐头去尾的`s+s`中判断是否有`s`存在
  * 改进
    * 满足题意的`s`还具备的特点：
      * 其最小重复子串`substring = t`重复n次就是`s`
      * 所以我们需要找到这个最小重复子串，然后判断其长度能否被`s`的长度整除即可
      * 寻找利用的原理：如果 $S$ 长为 $N$，且由长为 $P$ 的最小子串重复构成，那么 $S$ 的最长相等前后缀（Longest Prefix Suffix） 的长度一定是 $L_{Max}=N - P$。
        * 还有个trival特点：$L_{Max} > 0$ （必须有公共前后缀）
    * 特点证明：
      * 充分性：不可能有比$L_{Max}$更长的相等前后缀
        * 反证法：假设有比$L_{Max}$更长的相等前后缀
        * ![alt text](20240913114348.png)
        * ![alt text](20240913114818.png)
        * 通过配对，可以得到p2=p1，p3=p2，即p1=p2=p3,p=3*p1
        * 此时最小子串是p1而不是p，与条件矛盾，所以假设错误。
        * 同时，因为此时$L_{Max}$是最长的了，则 $P$ 此时一定是重复子串中最短的。
      * 必要性：若$S$ 长为 $N$， $S$ 的最长相等前后缀$L_{Max}=N - P$，则其一定可以由长为 $P$ 的子串重复构成：
        * 长为 $P$ 的子串从几何图解上来看就是错位串。
        * ![alt text](20240910174249.png)
        * 匹配可得：[0,1]=[2,3]=[4,5]=[6,7]
        * 匹配顺序：s[0,1]=t[0,1]=k[0,1]=s[2,3]=t[2,3]=k[2,3]=s[4,5]=t[4,5]=k[4,5]=s[6,7]
        * 即s可由s[6,7]重复组成。