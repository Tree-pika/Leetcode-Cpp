# swap
* 数值交换：
  * ```cpp
    int tmp = s[i];
    s[i] = s[j];
    s[j] = tmp;
* 利用位运算
  * ```cpp
    s[i] ^= s[j];//s[i] = A^B
    s[j] ^= s[i];//s[j] = B^(A^B) = A ^ (B ^ B) = A ^ 0 = A
    s[i] ^= s[j];//s[i] = (A^B)^A = B
  * 利用异或运算具有可逆性：如果 a ^ b = c，那么 c ^ b = a 且 c ^ a = b
  * 不需要额外变量
  * 不能用于交换同一个变量（即 i == j 时），因为会导致该变量变为 0。
  * 在现代编译器优化下，使用临时变量的交换通常更高效。
* 库函数：
  * `#include <utility>// 或 <algorithm>`
  * 容器有自己的`swap()`：所有 STL 容器（vector、string、map…）都提供
    * `void container::swap(container& rhs) noexcept;`
    * 位于对应容器的头文件中
    * 不是用于内部元素交换，而是将两个容器的内部数据结构（指针、大小、容量等）整体对调：常数时间，交换指针
# 151
* 我的解法
* ```cpp
      string reverseWords(string s) {
        int n=s.length();
        string res;
        for(int i=n-1;i>=0;){
            while(i>=0&&s[i]==' ') i--;
            if(i<0) break;//前面只剩下空格的情况，比如case2，hello前面只有空格了
            // string t;
            int right = i;
            while(i>=0&&s[i]!=' ')
                // t+=s[i--];
                i--;
            // reverse(t.begin(),t.end());
            /*substr(start_pos, length)*/
            if(res.empty()) res+=s.substr(i+1,right-i);
            else res+=' '+s.substr(i+1,right-i);
        }
        return res;
    }

* 时间复杂度$O(N)$:
  * 指针 i 从字符串末尾一直移动到开头，中间没有回退（即 i 从未增加）。因此，字符串中的每个字符最多被访问常数次。
  * s.substr(i+1, right-i)：提取子串的操作需要复制字符，耗时与单词长度成正比。所有单词长度之和不超过 $n$
  * res += ...：字符串拼接操作。虽然 C++ std::string 在追加时可能会重新分配内存，但在均摊（Amortized）情况下，追加操作是线性的。
* 空间复杂度$O(N)$
  * 结果存储 (res)：需要一个全新的字符串 res 来存储处理后的结果。在最坏情况下（没有多余空格），res 的长度接近 s 的长度。这是主要的内存消耗。
  * 临时变量：
    * s.substr(...) 会生成临时的 string 对象。在每次循环中，这个临时对象的最大长度取决于最长单词的长度。
    * 字符串拼接 res += ' ' + ... 过程中也产生临时的字符串对象(分两步，都变为res+=string的形式，这样可以直接追加到res后面)
* 【待完成】类似题：58. Length of Last Word
* inplace solution
  * 先去掉所有多余的空格：双指针法原地移除
    * 慢指针指向处理完的干净字符串的后一位
    * 快指针寻找所有单词，作为一个"提取器"
    * 对于找到的单词，若不是第一个，需要先在前面加一个空格(题目保证s 中使用至少一个空格将字符串中的单词分隔开。所以慢指针永远在快指针左边)
  * 因为可能有多余的空格，所以slow指向的内容大概率是没有覆盖完原字符串的所有位置的，也就是后面有一些多余元素，使用resize将它们截断
    * 此时新字符串的大小=slow
  * 然后翻转整个字符串
  * 最后依次翻转每个单词内部
  * 优势：
    * 内存友好：之前的写法中，string res、string t 都会申请堆内存。如果字符串非常大（例如几十 MB 的日志文件处理），频繁申请内存和拷贝会造成性能瓶颈。而原地解法没有这些开销。
    * 工程思维：在系统底层开发（如操作系统内核、嵌入式开发）中，内存往往是受限的。掌握“原地操作”体现了对计算机体系结构的理解（减少 Cache Miss，减少内存分配）。
# kama55--右旋转算法
* inplace solution
  * 借鉴151的思路，利用整体反转+局部反转就可以实现
  * 翻转整体
  * 翻转前 k 个
  * 翻转剩余部分
* 自己实现`reverse`，接受参数是迭代器
  * ``` cpp
    template<class BidirIt>
    void my_reverse(BidirIt first,BidirIt last){
        while(first!=last--&&first!=last){//这样的条件才能同时满足有奇数和偶数个元素的容器
            iter_swap(first,last);
            first++;
        }
    }
  * BidirIt 不是类，不是 typedef，只是 模板参数的名字，代表“任何双向迭代器类型”，用来写通用算法。
* 左旋转思路一模一样，只是区间变一下
# 字符串
* 易错点：
  * 字符串结束标志是'\0'，但是很多时候我们需要和' '打交道，这个时候遍历到最后一个元素'\0'也不会停下来
  * 所以当往右移动索引的时候，往往需要**先**加上条件限制类似`i<n`