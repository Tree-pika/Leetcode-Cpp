# 350
* 复杂度分析
* 时间复杂度：O(n+m)，其中 n 是 nums1的长度，m 是 nums2的长度。
* 空间复杂度：O(n)。
* 进阶三问
  * 如果给定的数组已经排好序呢？你将如何优化你的算法？
    * 用双指针解决。空间复杂度优化至 O(1)。
  * 如果 nums1 的大小比 nums2 小，哪种方法更优？
    * 讨论哈希表做法。可以把长度小的数组转成哈希表，这样可以做到 O(min(n,m)) 的空间复杂度。
  * 如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？
    * 用一个小型缓冲区（buffer）一边读数据一边遍历数据。这等价于问 nums2是一个流（Stream）的情况要怎么做。由于我们写的是一次遍历的代码，所以已经符合这个要求。
    * 如果内存十分小，不足以将数组全部载入内存，那么必然也不能使用哈希这类费空间的算法，只能选用空间复杂度最小的算法，即解法一--双指针。
    * 但是解法一中需要改造，一般说排序算法都是针对于内部排序，一旦涉及到跟磁盘打交道（外部排序），则需要特殊的考虑。归并排序是天然适合外部排序的算法，可以将分割后的子数组写到单个文件中，归并时将小文件合并为更大的文件。当两个数组均排序完成生成两个大文件后，即可使用双指针遍历两个文件，如此可以使空间复杂度最低。
    * 关于外部排序与JOIN，强烈推荐大家看一下 [数据库内核杂谈（六）：表的 JOIN（连接）](https://www.infoq.cn/article/6XGx92FyQ45cMXpj2mgZ)

# 349
* hash set
  * res用哈希集合存储，是为了给结果去重
  * 而nums1用哈希集合存储，是为了实现$O(1)$查找：因为res去重已经足够，所以这里给用hash set主要目的不是为了去重
