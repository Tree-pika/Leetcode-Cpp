* 1
  * bruce solution:
    * 两层for循环，第一层从左到右遍历数组中的每个数（直到倒数第二个，因为至少需要两个数）
    * 第二层遍历剩余的数，依次判断这组数是否相加之和等于target
  * 滑动窗口
    * 不行
    * 因为两个数可以是不连续的
  * 哈希法
    * 当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。
    * 本题转化为查询的解决思路：
      * 先将所有元素放入map中(因为可以无序，选择`unordered_map`)，使用map而非set是因为还需要返回下标，但是判断又需要用值
      * 因为我们要查的条件是关于值的，而`unordered_map`提供的快速查询服务只针对`key`，所以我们要用元素值作为`key`，下表作为`val`
      * 又因为`map`是去重的，而数组中可能多次出现同一个值，所以此时`val`需要设为一个`vector`
    * **改进思路**
      * map中存放访问过的元素
      * 每次去遍历数组，向map去查询是否有和目前遍历元素匹配的数值，如果有，就找到的匹配对，直接返回；如果没有，就把目前遍历的元素放进map中
      * 因为是先匹配再插入，所以不用担心相同的元素作为`key`第二次插入的问题：如果符合条件，直接返回；如果不符合条件，第二次插入失败，后面的其他元素想再和这个元素匹配也是可以的。因为有第一次插入的`key`在。
    * 双指针法：
      * 不行
      * 因为题目要求返回的是索引下标， 而双指针法一定要排序，一旦排序之后原数组的索引就被改变了。
      * 若要求返回的是数值，就可以用。
* 454
  * $nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0$可以转化为
    * $nums1[i] + nums2[j] =-(nums3[k] + nums4[l] )$
    * $target=-target$
  * 对于 A 和 B，我们使用二重循环对它们进行遍历，得到所有 A[i]+B[j] 的值并存入哈希映射中。对于哈希映射中的每个键值对，每个键表示一种 A[i]+B[j]，对应的值为 A[i]+B[j] 出现的次数。
  * 对于 C 和 D，我们同样使用二重循环对它们进行遍历。当遍历到 C[k]+D[l] 时，如果 −(C[k]+D[l]) 出现在哈希映射中，那么将 −(C[k]+D[l]) 对应的值累加进答案中。
    * 可能会有不同的(k,l)满足(C[k]+D[l])是同一个值，但是我们本就是要找到所有不同的下标组合
  * 【待完成】思考题：给出一个数组（而不是四个数组），在这里找出四个元素相加等于0，答案中不可以包含重复的四元组

* 【待完成】思考题：454中改成 i<j<k<l 怎么做？
  * 3404
* 15三数之和
  * 题意：不重复的三元组指，三元组可以看作是一个集合，所以三个元素相同只是顺序不同，也算重复的三元组。（[-1,0,1]和[0,1,-1]就是重复的）
  * 排序+双指针：$O(N^2)$，相比暴力求解降一个数量级
    * 排序是为了方便跳过重复数字组合$O(NlogN)$
    * 外层循环：使用一个固定索引，从数组的最左端一直指到倒数第三个数，每轮固定不动，记为nums[k]
    * 进入判断之前的：
      * 剪枝:若nums[k]>0,直接break，说明整个数组中不存在这样的三数对
      * 去重：当k>=1时，即至少为第二个固定的数字时，若nums[k]=nums[k-1]，直接continue，因为属于这个**数字**的所有可能组合我们已经在nums[k-1]的时候找完了。接下来找属于重复组合。
      * 若nums[k]+nums[n-2]+nums[n-1]<0，直接continue，说明当前的固定数字太小了
    * 内层循环：每轮中，使用两个指针i和j，指向开区间(k,nums.size())的最左和最右端，
      * 判断此时的sum = nums[k]+nums[i]+nums[j]：
        * =0，则i右移，跳过所有重复数字；j也需要左移，跳过所有重复数字（虽然i右移已经满足题目的不重复三元组的要求了，但是在nums[i]增大的情况下，若nums[j]不减小，sum不可能再次为0）
        * >0,则j左移，跳过所有重复数字
        * <0,则i右移，跳过所有重复数字
  * 【待完成】类似题：167;灵茶山
  * **哈希法**
    * 我们先统计nums中每种数字出现的词频到maps中
    * 性能开销大：然后两层for循环列举所有可能的(i,j)(i!=j) = (a,b)组合
    * 改进的思路：使用双重循环遍历哈希表中任意两个不同种类的数（包括自身），计算它们的和 sum = a + b，再在maps中查找是否存在`key` c = -sum。
      * 这样可以避免对于对于相同的a/b重复遍历多次
      * 然后还有判断，避免重复用了同一个数字（同一种可以）
        * 根据三数是否相同，分类判断是否有足够的频数来组成合法的三元组。
        * 三者都相等：一种情况
        * 两两相等：三种情况
      * 然后给得到的三元组排序后放入unordered_set res中,为了给结果自动去重
        * 必须在这里排序，最开始给nums排序没用，因为遍历的时候会打乱顺序(unordered_map元素插进去就是无序的)
    * 最后使用迭代器将res倒入ans中；或者直接类型转换
  * 优化后的哈希法
    * 迁移两数之和的思路，nums[i] + nums[j] + nums[k] == 0可以转化为target = -nums[i] =  nums[j] + nums[k]
    * 为了后续的剪枝与去重，和双指针法一样，先给nums排序
    * 也就是我们外层循环固定nums[i]，然后内层的遍历变为two-sum的问题
      * 进入内层遍历之前的
        * 剪枝：nums[i]>0，直接break，因为nums现在是升序的
        * 去重：i>=1时，若nums[i]==nums[i-1]，continue，所有属于这个数的组合已经找完了
    * 内层遍历：
      * 就是两数之和的思路
      * 但是要加上手动去重(或者将result先放到`set<vector<int>>`中利用set的自动去重，然后最后在将结果导入到`vector<vector<int>>`，但是维护一个set的成本很高，数据量大时不现实)：
        * 因为两数之和中题目确保只有一个答案，找到之后直接返回了，不用加上去重
        * 本题去重：因为已经固定了第一个数，对于第二个数nums[j]，若找到了need，后面与nums[j]相同的数直接跳过，因为不跳过，它们肯定会和nums[j]找到相同的need，这样就是重复的三元组了。
* 18:四数之和
  * Bruce solution：$O(N^4)$
  * 排序+双指针法:$O(N^3)$降一个数量级
    * 在三数之和的基础上，外层循环变为双层，每次固定两个值nums[i]=a,nums[j]=b
    * 因为题目要求i!=j，所以外层遍历时需要给索引一定的条件限制：
      * i从0到倒数第4个
        * 进入循环前的去重：i>=1时，若nums[i]=nums[i-1]，则直接continue；因为所有这个**值**对应的四元组已经在nums[i-1]时找完了。
        * 剪枝优化一:if(a>target&&a>=0) break;//,a非负是确保sum>=a(否则如果后面sum可能小于a的话，a>target也有可能出结果)
      * j每次从i+1到倒数第3个
        * 进入循环前的去重：j>=i+2(这个值是根据每次循环的开始索引来决定的，所以这里写j>=2就不对)时，若nums[j]=nums[j-1]，则直接continue；因为所有这个**值**对应的四元组已经在nums[j-1]时找完了。
        * 剪枝优化二:if(a+b>target&&b>=0) break;//b非负是确保sum>=a+b
    * 内层还是用双指针遍历
      * 左指针和右指针
      * 先判断当前是否满足四个数的和为target
      * 满足则加入结果`vector<vector<int>>`
        * 左指针右移跳过所有重复的数
        * 右指针左移跳过所有重复的数
      * sum>0
        * 右指针左移跳过所有重复的数
      * sum<0
        * 左指针右移跳过所有重复的数
      * 上面的移动可以用`while(i<j&&nums[i]==nums[++i]);`，因为这里至少要移动一次，所以直接使用前置++最快