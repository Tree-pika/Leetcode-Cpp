# 1、元素无重不可复选
## 子集78
* 组合/子集问题使用 start 变量保证元素 nums[start] 之后只会出现 nums[start+1..] 中的元素，通过固定元素的相对位置**保证不出现重复的子集**。
* 决策树
  * ![alt text](3.jpg)
  * ![alt text](4.jpg)
    * 集合 [2] 只需要添加 3，而不添加前面的 1 
    * 因为集合中的元素不用考虑顺序，[1,2,3] 中 2 后面只有 3，如果你添加了前面的 1，那么 [2,1] 会和之前已经生成的子集 [1,2] 重复。
  * 这棵树的特性：
    * 把根节点作为第 0 层
    * 将每个节点和根节点之间树枝上的元素作为该节点的值
    * 第 n 层的所有节点就是大小为 n 的所有子集。
## 组合77
* 组合问题和子集问题其实是等价的：大小为 k 的组合就是大小为 k 的子集。
* 所以改下 子集backtrack 函数中的 base case，仅收集第 k 层的节点值即可

# 2、元素可重不可复选
## 子集90
* 全集中可能有重复元素
* 但是子集和组合都是不考虑元素顺序的，也就是说[1,2]和[2,1]算重复子集
* 比如[1,2,2]有了可重元素，就会导致出现重复子集
按照1的思路，得到的子集如下
```text
    [ 
        [],
        [1],[2],[2'],
        [1,2],[1,2'],[2,2'],
        [1,2,2']
    ]
```
* 显然有重复，正确结果应该如下：
```
    [ 
        [],
        [1],[2],
        [1,2],[1,2],
        [1,2,2']
    ]
```
* 对应到决策树中，重复的子集是这样产生的：
  * ![alt text](8.jpg)
  * 两条值相同的相邻树枝会产生重复
    * 为了方便判断相同，**需要先给全集元素排序**，这样相同元素肯定是相邻的
  * 解决办法：剪枝
    * ![alt text](9.jpg)
## 组合40
```cpp
    /*base case,超过目标和，直接结束--剪枝1：基础版
    剪纵向：只阻止了向更深处搜索，后序更大的兄弟分支没有剪掉*/
    if(sum>target){
        return;
    }
```
* 这种通过return剪枝，是直接回退到上一层调用自己的地方，也就只能纵向剪枝
* 属于进入递归后检查
```cpp
        for(int i=start;i<candidates.size();i++){
            /*剪枝2:优化版
            横向 + 纵向：阻止了当前深搜，且斩断了本层后续所有横向遍历*/
            if(sum+candidates[i]>target) 
                break;
            //...
        }
```
* 这种break剪枝，除了将本层剪掉了，同层的右侧兄弟节点也一起剪掉了，属于进入递归前检查

# 3、元素无重可复选
## 组合39
* 上面两种场景保证不重复使用元素的方法：利用start参数
  * 这个 i 从 start 开始，那么下一层回溯树就是从 start + 1 开始，从而保证 nums[start] 这个元素不会被重复使用
  * 解集去重的方法：控制只能往右选元素
* 本题想让每个元素被重复使用，只要把 i + 1 改成 i 即可
  * ![alt text](10.jpg)
  * 但是也控制了i之前的元素不能再选，从而去重，即整体是只能往右选(虽然包含了当前元素)的