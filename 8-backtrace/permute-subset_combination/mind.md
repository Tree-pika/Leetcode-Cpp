* 组合问题的常见三种变体形式
  * 形式一、**元素无重不可复选**，即 nums 中的元素都是唯一的，每个元素最多只能被使用一次，这也是最基本的形式。
    * 以组合为例，如果输入 nums = [2,3,6,7]，和为 7 的组合应该只有 [7]。
  * 形式二、**元素可重不可复选**，即 nums 中的元素可以存在重复，每个元素最多只能被使用一次。
    * 以组合为例，如果输入 nums = [2,5,2,1,2]，和为 7 的组合应该有两种 [2,2,2,1] 和 [5,2]。
    * 元素可重时，为了方便剪枝，一般需要先对全集元素进行排序
  * 形式三、**元素无重可复选**，即 nums 中的元素都是唯一的，每个元素可以被使用若干次。
    * 以组合为例，如果输入 nums = [2,3,6,7]，和为 7 的组合应该有两种 [2,2,3] 和 [7]。
* 排列、组合、子集问题都可以有这三种基本形式，所以共有 9 种变化。
  * 还有其他灵活的变体形式
  * 但本质就是穷举所有解，而这些解呈现树形结构，所以合理使用回溯算法框架即可。
  * 组合问题和子集问题其实是等价的：大小为 k 的组合就是大小为 k 的子集。
  * 三种变化形式，无非是在下面两棵树上剪掉或者增加一些树枝罢了。
  * ![alt text](1.jpg)
  * ![alt text](2.jpg)
* 回溯算法很容易超时，所以超时的时候，去思考看看当前的程序有哪些可以剪枝的优化。

# 总结思路
* 形式一、元素无重不可复选，即 nums 中的元素都是唯一的，每个元素最多只能被使用一次。
  * 组合/子集：结果无序，利用start索引控制每次只能在上一层选过的数字后面继续选。
  * 排列：结果有序，所以每一层理论上可以使用的数字都是全集，为了避免复选，可以使用used标记已选元素。
  ```cpp
  // 组合/子集问题回溯算法框架
  void backtrack(vector<int>& nums, int start) {
    
  }
  ```
* 形式二、元素可重不可复选，即 nums 中的元素可以存在重复，每个元素最多只能被使用一次，其关键在于排序和剪枝。
  * 排序是为了对于同一层：相同数值的元素只选一次，其余的剪掉，因为它们产生的结果集肯定是一样的  
  ```cpp
  ```
* 形式三、元素无重可复选，即 nums 中的元素都是唯一的，每个元素可以被使用若干次，只要删掉去重逻辑即可  
  ```cpp
  ```