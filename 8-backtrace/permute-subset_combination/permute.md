# 元素无重不可复选46
* 用 used 数组标记已经在路径上的元素避免重复选择，然后收集所有叶子节点上的值，就是所有全排列的结果。
* ![alt text](7.jpg)
* 进一步：算元素个数为 k 的排列
  * 改下 backtrack 函数的 base case，仅收集第 k 层的节点值即可

# 元素可重不可复选47
* 有重复元素的全集nums=[1,2,2',2''],如何找出不重复的全排列：
  * 也就是问不重复的全排列有什么特征，可以从所有可能的全排列中，将这一部分提取出来
* 方法1：
  * 模仿子集/组合问题中的剪枝思路，对于**本层**的非第一次出现的相同的树枝，剪掉即可
  * ![alt text](11.jpg)
  * 相同树枝下面的子树也会长得一模一样，所以会出现重复的排列。
  * 因为排序之后所有相等的元素都挨在一起，所以只要用 prevNum 记录前一条树枝的值，就可以避免遍历值相同的树枝，从而避免产生相同的子树，最终避免出现重复的排列。
    * 
    ```cpp
    int preNum=-11;//对于每一层，第二次及更后出现的相同枝干剪掉
    for(int i=0;i<nums.size();i++){
        if(used[i]){
            continue;
        }
        // 去重：如果当前数字和本层上一次尝试的数字一样，跳过
        // 优化树层去重
        if(nums[i]==preNum){
            continue;
        }
        //...
    }
    ```
  * 这是去掉**树层重复**的思路
  * **“树层重复”和“树枝重复”**
    * 树层重复（Horizontal）：在同一个位置尝试放 $1_A$ 之后，又尝试放 $1_B$。这是我们要避免的（因为 $1_A$ 开头的排列和 $1_B$ 开头的排列是一样的）。
    * 树枝重复（Vertical）：我先放了 $1_A$，然后在下一个位置（子节点）放了 $1_B$。这是完全合法的！因为它们是同一个数组里的两个不同的元素，只是值相等而已。
    * 
    ```cpp
    for(int i=0;i<nums.size();i++){
        if(used[i]){
            continue;
        }
        if(i>0&&nums[i]==nums[i-1]) 
              continue;
        //...
    }
    ```
    * 所以上面这种写法不对：因为 `nums[i] == nums[i-1]`不止包括树层重复的情况(即本层树枝相同)，还包括作为父节点已经被选进 path、而重复的情况(这是树枝重复)
      * 修正：再在判断中添加一个限制条件，只有当前面那个相同的兄弟没被用（说明是回溯回来的），我才算重复；如果前面那个兄弟**正在被用**（说明它是**我的长辈**），那我不算重复。
* 方法2：保证**相同元素**在排列中的**相对位置保持不变**。
  * 只要保证重复元素 2 的相对位置固定，比如说 2 -> 2' -> 2''，就可以得到无重复的全排列结果。
    * 即对于2'，其永远不可能在第一个位置出现，因为2必须先于2'出现。
    * 看后面的分析就知道，保持这种相对位置，实际上还是进行了树层重复的剪枝--本层2已经作为领头羊把所有的情况都跑了一遍了，其他的2就不要再执行一遍了--剪掉
  * 分析：
    * 标准全排列算法之所以出现重复，是因为把相同元素形成的排列序列视为不同的序列，
    * 但实际上它们应该是相同的；
    * 而如果固定相同元素形成的序列顺序，当然就避免了重复。
  * 实现相对位置不变的方法：选取元素添加到结果排列中时，添加控制条件：
    * 2' 只有在 2 已经被使用的情况下才会被选择，
    * 同理，2'' 只有在 2' 已经被使用的情况下才会被选择
* 如果 nums[i] == nums[i-1]，同时有：
  * used[i-1] == true：它是我的直系祖先（正在路径中）。nums[i]是被祖先调用的下一层，虽然数字重复，但属于不同层，可以选。
  * used[i-1] == false：它是我的孪生兄弟（刚刚演示完）。说明发生了：
    * 曾经被选过：在一个更早的时间点（同一个父节点的 for 循环里），i-1 肯定先被遍历到了（因为 i 是从 0 递增的）。
    * 已经回溯了：既然现在轮到了 i，说明 i-1 的那次递归调用已经彻底结束并返回了。
    * 状态重置：返回后，used[i-1] 被改回了 false。
    * 作为**同一层**的重复值，nums[i]应该被剪掉

## 子集/组合去重 VS 全排列去重
| **特性**             | **LeetCode 90 (子集 II)**           | **LeetCode 47 (全排列 II)**                   |
| -------------------- | ----------------------------------- | --------------------------------------------- |
| **搜索范围**         | `[start, end]` (只能往后看)         | `[0, end]` (回顾整个数组)                     |
| **父节点的位置**     | 索引一定 `< start`                  | 索引分布在 `[0, end]` 任意位置                |
| **`nums[i-1]` 身份** | 当 `i > start` 时，必为**兄弟**     | 可能是**兄弟**，也可能是**父亲**              |
| **去重手段**         | `i > start && nums[i] == nums[i-1]` | `i > 0 && nums[i] == nums[i-1] && !used[i-1]` |
| **难度**             | 较简单 (索引天然隔离)               | 较难 (需要状态数组辅助判断)                   |

---
1. 前面两种场景是利用used 数组进行剪枝，避免重复使用同一个元素。
2. 对于元素可重集合，还需进一步剪枝，不止要求nums[i]这个**元素**没用过，它的**值**也不能在**本层**被用过
3. 下面，讨论元素无重复且可复选的全排列情况
   * 去掉used数组剪枝的限制即可
```cpp
class Solution {
public:
    vector<vector<int>> res;
    deque<int> track;

    vector<vector<int>> permuteRepeat(vector<int>& nums) {
        backtrack(nums);
        return res;
    }

    // 回溯算法核心函数
    void backtrack(vector<int>& nums) {
        // base case，到达叶子节点
        if (track.size() == nums.size()) {
            // 收集叶子节点上的值
            res.push_back(vector<int>(track.begin(), track.end()));
            return;
        }

        // 回溯算法标准框架
        for (int i = 0; i < nums.size(); i++) {
            // 做选择
            track.push_back(nums[i]);
            // 进入下一层回溯树
            backtrack(nums);
            // 取消选择
            track.pop_back();
        }
    }
};
```
