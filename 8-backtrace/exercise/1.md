# 练习
* 解决一个回溯问题，实际上就是遍历一棵决策树的过程，树的每个叶子节点存放着一个合法答案。你把整棵树遍历一遍，把叶子节点上的答案都收集起来，就能得到所有的合法答案。
* 站在回溯树的一个节点上，你只需要思考 3 个问题：
  * 1、路径：也就是已经做出的选择。
  * 2、选择列表：也就是你当前可以做的选择。
  * 3、结束条件：也就是到达决策树底层，无法再做选择的条件。
* **回溯**算法的代码框架：
  ```python
  result = []
  def backtrack(路径, 选择列表):
      if 满足结束条件:
          result.add(路径)
          return
      
      for 选择 in 选择列表:
        # 做选择：前序位置
        将该选择从选择列表移除
        路径.add(选择)
        backtrack(路径, 选择列表)
        # 撤销选择：后序位置
        路径.remove(选择)
        将该选择再加入选择列表
  ```
* **重点练习**：怎么定义“**选择列表**” 和 怎么定义“**路径**”。

---
# 练习总结
* 括号问题可以简单分成两类，一类是前文写过的括号的合法性判断 ，一类是合法括号的生成。对于括号合法性的判断，主要是借助「栈」这种数据结构，
* 而对于括号的生成，一般都要利用回溯算法 进行暴力穷举。
## 切割问题
* 切割问题就可以使用回溯搜索法把所有可能性搜出来--LC-131/93
  * startIndex一定是需要的，因为不能重复分割，记录下一层递归分割的起始位置。
## 79单词搜索DFS
```cpp
private:
    bool found;
    int dirs[4][2] = {{-1,0},{1,0},{0,-1},{0,1}};//choice offsets
    vector<vector<bool>> visited;
    int m,n;
    // 从 (r,c) 开始向四周搜索，试图匹配 word[index..]
    void backtrack(vector<vector<char>>&board,string word,int r,int c,int index){
        if(index==word.length()){
            // 整个 word 已经被匹配完，找到了一个答案
            found = true;
            return;
        }
        //剪枝优化：已经找到了，就停止再找了
        if(found){
            return;
        }
        //base case
        if(r<0||r>=m||c<0||c>=n||visited[r][c]){
            return;
        }
        //字母不匹配
        if(board[r][c]!=word[index]){
            return;
        }
        //做选择:做标记，避免走回头路
        visited[r][c] = true;
        //word[p] 被 board[r][c] 匹配，开始向四周搜索 word[index+1..]
        for(int k=0;k<4;k++){
            backtrack(board,word,r+dirs[k][0],c+dirs[k][1],index+1);
        }
        //撤销选择
        visited[r][c] = false;
    }
```
* 因为题目说board 和 word 仅由大小写英文字母组成，所以可以不用额外使用一个visited数组来防止走回头路，直接使用一个特殊字符来进行标记即可,比如加负号，比如替换成#，这样`board[r][c]`可以代表两种情况,一是(可能刚好也匹配但)已经被访问过了，二是字母不匹配
* 下面是改进后的版本：
```cpp
private:
    bool found;
    int dirs[4][2] = {{-1,0},{1,0},{0,-1},{0,1}};//choice offsets
    int m,n;
    // 从 (r,c) 开始向四周搜索，试图匹配 word[index..]
    void backtrack(vector<vector<char>>&board,const string&word,int r,int c,int index){
        //结束条件
        if(index==word.length()){
            // 整个 word 已经被匹配完，找到了一个答案
            found = true;
            return;
        }
        //剪枝优化：已经找到了，就停止再找了
        if(found){
            return;
        }
        //base case
        if(r<0||r>=m||c<0||c>=n){
            return;
        }
        //剪枝：字母不匹配
        if(board[r][c]!=word[index]){
            return;
        }
        //做选择：进行标记
        char tmp = board[r][c];
        board[r][c] = '#';
        //word[p] 被 board[r][c] 匹配，开始向四周搜索 word[index+1..]
        for(int k=0;k<4;k++){
            backtrack(board,word,r+dirs[k][0],c+dirs[k][1],index+1);
        }
        //撤销选择
        board[r][c] = tmp;
    }
public:
    bool exist(vector<vector<char>>& board, string word) {
        found = false;
        m = board.size();
        n = board[0].size();
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                //剪枝:只有当起点字符匹配时，才开始回溯
                if(board[i][j]==word[0]){
                    backtrack(board, word,i, j, 0);
                    if (found) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
```
* void 返回值 + 全局变量 found + 头部剪枝 `if(found) return`
* 这种不能立即短路：假设 k=0 时已经找到了答案，将 found 设为 true 并返回了。
  * 但是！程序回到for 循环还会继续执行 k=1, k=2...
  * 虽然你在 backtrack 头部加了 if(found) return，
  * 但程序还是必须发生函数调用（压栈），进去看一眼，发现 found 是 true，再退出来（弹栈）。
* 改进思路：标准的“存在性判断”回溯，通常使用 bool 返回值。一旦某一条路返回 true，上层直接 if (result) return true，不再尝试后续的 for 循环。
  * 无论是 void 还是 bool，return 语句的作用永远只是回到它的上一层调用者（Caller）那里
  ```cpp
      // 从 (r,c) 开始向四周搜索，试图匹配 word[index..]，返回word是否匹配成功
    bool backtrack(vector<vector<char>>&board,const string&word,int r,int c,int index){
        //base case1:越界/当前字母不匹配
        if(r<0||r>=m||c<0||c>=n||board[r][c]!=word[index]){
            return false;
        }
        //base case2：结束条件
        if(index==word.length()-1){
            // 最后一个字符刚被匹配完，说明word全部匹配成功
            return true;
        }
        //做选择：进行标记
        char tmp = board[r][c];
        board[r][c] = '#';
        
        //word[p] 被 board[r][c] 匹配，开始向四周搜索 word[index+1..]
        for(int k=0;k<4;k++){
            //如果某一个方向找到了，立刻返回 true，不再试其他方向
            if(backtrack(board,word,r+dirs[k][0],c+dirs[k][1],index+1)){
                return true;
            }
        }
        //撤销选择
        board[r][c] = tmp;

        return false;
    }
  ```
  * 上面的`for`循环相当于短路机制：
    * 假设递归深处（第 3 层）找到了答案。
    * 第 3 层：return true; （任务完成！）
    * 第 2 层：接收到 true。if(true) 成立 -> 执行 return true; （立刻停止循环，向上汇报）
    * 第 1 层：接收到 true。if(true) 成立 -> 执行 return true;
    * 第 0 层 (Main)：接收到 true。游戏结束。
  * 虽然每一层只返回给上一层，但因为每一层都写了“如果收到好消息就立刻上报”的逻辑，所以信号像电流一样瞬间传到了顶层。