> 对应二叉树算法的核心思想的第一类：遍历一遍二叉树得出答案，即「遍历」解决问题的思想
> 函数签名一般是 void backtrack(...)，没有返回值，靠更新外部变量来计算结果
* **总述**：动归/DFS/回溯算法都可以看做二叉树问题的扩展，只是它们的关注点不同：
  * 动态规划算法属于分解问题（分治）的思路，它的关注点在整棵「子树」：结构相同的整个子问题。
  * 回溯算法属于遍历的思路，它的关注点在节点间的「树枝」：节点之间移动的过程。
  * DFS 算法属于遍历的思路，它的关注点在单个「节点」：单一的节点上。
    * 和回溯算法没有本质区别，就是根据题目要求不同，灵活应用。
* 解决一个回溯问题，实际上就是遍历一棵决策树的过程，树的每个叶子节点存放着一个合法答案。你把整棵树遍历一遍，把叶子节点上的答案都收集起来，就能得到所有的合法答案。
* 站在回溯树的一个节点上，你只需要思考 3 个问题：
  * 1、路径：也就是已经做出的选择。
  * 2、选择列表：也就是你当前可以做的选择。
  * 3、结束条件：也就是到达决策树底层，无法再做选择的条件。
* 回溯算法的代码框架：
  ```python
  result = []
  def backtrack(路径, 选择列表):
      if 满足结束条件:
          result.add(路径)
          return
      
      for 选择 in 选择列表:
        # 做选择：前序位置
        将该选择从选择列表移除
        路径.add(选择)
        backtrack(路径, 选择列表)
        # 撤销选择：后序位置
        路径.remove(选择)
        将该选择再加入选择列表
  ```
  * for 循环里面的递归:在递归调用之前「做选择」，在递归调用之后「撤销选择」
* 用全排列来弄懂上面的思路
  * n 个不重复的数，全排列共有 n! 个
  * ![alt text](2.jpg)
  * 对于上图红色节点：[2] 就是「路径」，记录你已经做过的选择；[1,3] 就是「选择列表」，表示你**当前**可以做出的选择；「结束条件」就是遍历到树的底层叶子节点，这里也就是**选择列表为空**的时候。
  * 定义的 backtrack 函数其实就像一个指针，在这棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层叶子节点，其「路径」就是一个全排列。
    * ![alt text](3.jpg)
  * 前序位置做选择，后序位置撤销选择
    * 这里注意backtracking算法中后序/前序位置在for循环内部，而DFS和多叉树的DFS遍历后序/前序位置都在for循环外部(即等所有孩子都遍历完了后)
    * 回溯算法必须把「做选择」和「撤销选择」的逻辑放在 for 循环里面，否则怎么拿到「树枝」的两个端点。
    * ![alt text](5.jpg)
* 总结
  * 回溯不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高。
  * 最多可以通过剪枝来进行一定的优化。
  * 「节点的值」都是指节点和根节点之间**树枝**上的元素
    * 因为你在穷举排列组合的时候，就是在树枝位置做选择（往 track 里面添加的元素），节点中反映的是你此次选择的结果（track 的状态）
  * 且将根节点认为是第 0 层。