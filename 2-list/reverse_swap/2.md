# 反转链表
## 双指针法--迭代法
* 一个`pre`指针一个`cur`指针，从头移到尾，逐一改变指针的朝向
* 还需要一个临时指针`tmp`保留`cur`的下一个节点，因为`cur`要改变指针朝向
## 递归法
* 普通递归（后序遍历）：从后往前依次翻转指针
* 尾递归（前序遍历）：从前往后依次翻转指针
  * 特点是：我们在“去”的过程中就完成了反转，而不是等“回”的时候才做。
  * 在函数式编程语言（如 Haskell, Erlang）或者支持 TCO （Tail Call Optimization）的环境中，这种写法等价于迭代循环，它不需要消耗 $O(n)$ 的栈空间，可以避免栈溢出。
* 对比：
  * 第一种写法（从后往前，普通递归）
    * 思维：“我先不管现在这个节点，先让后面的一堆节点自己反转好，我再把自己接到后面去。”
    * 动作发生时机：归（Backtracking） 的时候。
    * 栈帧状态：系统栈会一直压入，直到链表尾部，然后在弹出的过程中修改指针。
  * 第二种写法（从前往后，尾递归）
    * 思维：“我现在就把当前这个节点的指针改了，改完之后，把剩下的烂摊子丢给下一次递归去处理。”
    * 动作发生时机：递（Forwarding） 的时候。
    * 逻辑对应：完全对应你的迭代法 while 循环体。reverseHelper 的参数传递 $\approx$ 迭代里的变量更新。
### 详细过程
用 `1 -> 2 -> 3 -> nullptr` 来逐步拆解。用缩进来表示**压栈（Call Stack）**的深度。

---

#### 第一种：普通递归（从后往前反转）
**代码回顾：** 先 `reverse(head->next)`，回来后再改指针。
**核心特点：** “递”的时候什么都不做，“归”的时候才干活。

1. 递（压栈过程）：一路向下寻找尽头
程序开始运行，不断调用函数，每一层都在等待下一层的结果。

* **第1层栈帧 `reverse(1)`**:
    * 不是终点。
    * **暂停**，调用 `reverse(2)` 等待结果...
    
    * **第2层栈帧 `reverse(2)`**:
        * 不是终点。
        * **暂停**，调用 `reverse(3)` 等待结果...
        
        * **第3层栈帧 `reverse(3)`**:
            * **触底！** (`head->next == nullptr`)
            * **直接返回** 节点 `3`。
            * （此时链表没变：`1->2->3->nullptr`）

2. 归（出栈过程）：从后往前修改指向
现在开始“弹栈”，每一层被唤醒，开始处理后事。

* **回到第2层 `reverse(2)`**:
    * 收到了第3层返回的 `newHead` (节点3)。
    * **执行逻辑**：
        1.  `head->next` 是 3。执行 `3->next = 2`。
        2.  `2->next = nullptr`。
    * **链表变成**：`1->2<-3` (1连着2，3连着2，2断开3)。
    * **返回** `newHead` (节点3) 给上一层。

* **回到第1层 `reverse(1)`**:
    * 收到了第2层返回的 `newHead` (节点3)。
    * **执行逻辑**：
        1.  `head->next` 是 2。执行 `2->next = 1`。
        2.  `1->next = nullptr`。
    * **链表变成**：`nullptr<-1<-2<-3` (即 `3->2->1->nullptr`)。
    * **返回** `newHead` (节点3)。

**结束**：拿到节点3，它是新的头。

---

#### 第二种：尾递归（从前往后反转）
**代码回顾：** `helper(prev, cur)`，先改指针，再递归。
**核心特点：** “递”的时候就把活干了，“归”的时候只是传话。

1. 递（压栈过程）：边走边改
初始调用：`helper(nullptr, 1)`

* **第1层栈帧 `helper(prev=null, cur=1)`**:
    * **干活**：把 `1->next` 改为 `null`。
        * 链表状态：`null<-1` `2->3` (1和2断开了，temp暂存了2)
    * **继续**：调用 `helper(1, 2)`。

    * **第2层栈帧 `helper(prev=1, cur=2)`**:
        * **干活**：把 `2->next` 改为 `1`。
            * 链表状态：`null<-1<-2` `3` (2指向1，3暂存)
        * **继续**：调用 `helper(2, 3)`。

        * **第3层栈帧 `helper(prev=2, cur=3)`**:
            * **干活**：把 `3->next` 改为 `2`。
                * 链表状态：`null<-1<-2<-3` (全部反转完成！)
            * **继续**：调用 `helper(3, null)`。

            * **第4层栈帧 `helper(prev=3, cur=null)`**:
                * **触底！** (`cur == nullptr`)
                * **返回** `prev` (即节点 3)。

2. 归（出栈过程）：单纯传值
因为活已经干完了，回来的过程就是把结果一层层透传上去。

* **回到第3层**：收到 3，返回 3。
* **回到第2层**：收到 3，返回 3。
* **回到第1层**：收到 3，返回 3。

**结束**：直接拿到节点3。

## 虚拟头结点-头插法-迭代法
* 这里的`dummy`并不是传统的哨兵的用法
* 可以把它理解为一个记录器，每次指向`cur`前面的结点，翻转链表的时候，只需要将`cur`的指向覆盖为当前`dummy`的指向即可。
* `dummy` 是一个固定的哨兵节点（Sentinel Node）。它永远不动，死死地钉在位置上。
* 但是，`dummy.next` 会不断变化，永远指向当前最新反转好的那个链表的头。
* 代码逻辑其实就是：把原本链表里的节点一个一个摘下来，插到 `dummy`和 `dummy->next` 之间。 就像排队插队一样，新来的永远插在第一个位置。
## 压栈法

# 双指针法
1. 删除倒数第n个结点
  * 设置一个dummy为node0
  * 链表中真实的结点为$node1$...$node_{size}$
* 快慢指针
  * 我们最终希望slow指针指向被删除结点的前一个位置
  * 所以关键的就是，slow从dummy开始，需要移动(size-n)步，刚好可以到达上述位置
  * 但是size的值只能通过扫描一遍才知道，所以我们需要一个快指针带我们走，绕开size
  * fast从dummy移动到最后的nullptr需要动(size+1)步，$(size+1)-(size-n) = (n+1)$
  * (size-n)步是fast带着slow走的部分，所以fast需要先走 (n+1)步
2. 相交链表
* 首先要明确：相交的结点判断标准是指针一样，即地址一样，同一个地址存的值肯定相等，但是值相等不是本质
* 相交的结点一定在短链表中，所以我们需要先将指向长链表的指针，指向一个结点，这个结点使得长链表的剩余长度与短链表一致：这个方法需要计算长度
* improve by 双指针
  * 消除长度差：两个指针分别从 headA 和 headB 出发，走完本链表后立刻切换到对方链表的头节点。
  * 最终效果：两个指针都走过 「lenA + lenB」 的路径，实现**路径等量**
  * 两个指针在遍历对方链表一定同时到达相交点（或同为 nullptr）。
    * 若两个链表长度相等，则在遍历自己的链表时，就会相交
3. 环形链表的入口
* 这类链表题目一般都是使用双指针法解决的，例如寻找距离尾部第 K 个节点、寻找环入口、寻找公共尾部入口等。
* 双指针的第一次相遇：
  * 设两指针 fast，slow 指向链表头部 head 。
  * 令 fast 每轮走 2 步，slow 每轮走 1 步。
  * 执行以上两步后，可能出现两种结果：
    * 第一种结果： fast 指针走过链表末端，说明链表无环，此时直接返回 null。
    * 如果链表存在环，则双指针一定会相遇。因为每走 1 轮，fast 与 slow 的间距 +1，fast 一定会追上 slow 。
    * 第二种结果： 当fast == slow时， 两指针在环中第一次相遇。下面分析此时 fast 与 slow 走过的步数关系：
      * 设链表共有 a+b 个节点，其中 链表头部到链表入口 有 a 个节点（不计链表入口节点）， 链表环 有 b 个节点；设两指针分别走了 f，s 步，则有：
      * fast 走的步数是 slow 步数的 2 倍，即 **f=2s**；（解析： fast 每轮走 2 步）
      * fast 比 slow 多走了 n 个环的长度，即 **f=s+nb**；（ 解析： 双指针都走过 a 步，然后在环内绕圈直到重合，重合时 fast 比 slow 多走 环的长度整数倍 ）。
      * 将以上两式相减得到 **f=2nb，s=nb**，即 fast 和 slow 指针分别走了 2n，n 个环的周长。
* **得到相遇时s=nb是关键，接下来的分析**：从head结点走到入环点需要走 ： a + nb， 而slow已经走了nb，那么slow再走a步就是入环点了。
* 如何知道slow刚好走了a步？ 从head开始，和slow指针同速一起走，相遇时刚好就是a步


