# dummy node
* 链表的一大问题就是操作当前节点必须要找前一个节点才能操作。这就造成了，头结点的尴尬，因为头结点没有前一个节点了。
* 每次对应头结点的情况都要单独处理，所以使用虚拟头结点的技巧，就可以解决这个问题。
* 可以统一处理单链表中的所有结点
* `ListNode* dummy = new ListNode(-1);`
* `dummy->next = head;`
# 节点创建
1.使用构造函数创建出对象`ListNode dummy(-1,head);`
* 这样创建的对象分配在`stack`上，编译器会在函数返回时自动析构并回收它的内存。
* 所以新增一个节点千万不能用这种方式，因为函数一返回，新节点就销毁了，此时取得地址也是栈地址，出了函数就没意义了--变成悬空指针，任何访问都是UB。
* `dummy`节点用这个没关系，因为本来出了函数我们就不希望它还存在的。

2.使用动态内存分配`new`创建对象`ListNode* dummy = new ListNode(-1,head);`
* 这样创建的对象分配在`heap`上，需要手动使用`delete`销毁，否则会内存泄漏
  * 在 C++11 以后可以用 `std::unique_ptr/std::shared_ptr `管理
* **创建新节点使用这个**，函数返回时不会自动销毁，地址仍然有效，可以继续使用；
  
# 双链表Doubly-List
* 对于双链表而言，`tail`节点比较特殊，它右边连接的是`nullptr`，空指针不会向左伸出一个手指向`tail`。
* 一般的节点都是左边连一个，右边连一个；然后左边被一个指，右边被一个指。
* `dummy`也特殊，它左边连接的是`nullptr`，所以左边不会被一个指。
* 而`nullptr`是不能做解引用的，也就是`nullptr->prev/nullptr->next/*nullptr`都不行，会触发未定义行为（UB）——最常见后果是程序直接崩溃（段错误 / access violation）
* 所以添加和删除节点的时候都需要注意`tail`这个特殊的节点，这个节点不需要被后一个节点指向，因为后一个节点是`nullptr`
* ```cpp
    if(to_delete->next)//确保不是空指针，nullptr->prev会造成段错误
        to_delete->next->prev = previous;

* 对于双链表来说，要想统一处理所有的节点的话，需要使用“双哨兵”--Double Sentinel
* 结构：`head(哨兵) <-> 真实节点1 <-> ... <-> 真实节点N <-> tail(哨兵)`
* 初始状态：head 指向 tail，tail 指向 head，中间没有任何真实节点。
* 最大优势：
  * 消除边界检查：无论你是插入第一个位置、中间位置还是最后一个位置，你永远是在“两个节点之间”插入。
  * 无需判空：你的 prev 和 next 指针永远指向一个有效的节点（可能是哨兵，但绝不是 nullptr），所以永远不会出现 ptr->next->prev 这种因为空指针导致的段错误。