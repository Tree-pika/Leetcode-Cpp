# 循环不变量
* 每次迭代按照固定的规则：
  * 固定左开右闭的区间
  * 二分查找时，固定查找区间为左闭右闭，则每次更新`mid = right-1;/mid = left+1;`
# 螺旋填充数组
1. 我的解法
   * 每一圈左闭右开，右下左上。四段区间的分割点，两个在主对角线上，两个在副对角线上，利用这个作为区分每段区间的条件。
   * 普通的走记为常规走圈，对于奇数数组来说，中间还有个单独的元素组成的非常规“圈”。
   * 走完一圈之后，行列索引会回到本圈的出发点，如果本圈确实走了（对于`n=1`的情况，其实是没有走常规圈的，此时`num`保持原值不变）--判断条件是`num>1`，则更新行列索引到下一圈的起点（即`i++`/`j++`）
     * 进行新的一轮走圈时，四段区间的终点（“右开”的值）都更靠近中心了，需要每次递减1，利用统一的`cnt`来控制。
   * 判断所有走圈都结束得标志就是：需要填的数字是否都填入。即`num>n*n`时，代表数字装载完毕，矩阵构造完成。
2. `Explicit Loop`（显式四边循环） 的写法
   * 通过控制走圈数来标志所有的常规圈走完
   * 每圈的每段的终点划分依赖一个`offset`，而不在乎行列索引在矩阵中的几何关系：判断更加轻盈
   * 正是因为我们使用的是左闭右开的区间，这意味着：如果这一行有 k 个格子，我们只填 k-1 个，把最后一个留给下一条边。
   * 循环的步长是当前圈边长-1；所以当奇数圈转到最后只剩下中心点时，此时循环步长 = 0，不会进入任何一个常规圈的`for`循环被赋值，所以需要我们最后单独处理。
3. 四边界收缩法
   * 关键点：每遍历/填充完一行/列，就将该边界往内部的位置挪一格，代表该行/列已经被遍历过，丢弃
   * 然后当上下边界/左右边界交叉（不是相等，相等时是解决中间的“芯”）时，说明所有的格子全部被遍历过了。
# 螺旋遍历数组
1. 循环不变量解法
   * 处理完正常的跑圈，剩下的关键的是中间芯的处理逻辑，要想处理，得先判断芯什么时候出现：最短边是奇数时。
   * 每一圈消耗 2 个单位的长度/宽度。
   * **螺旋会在最短的那条边归零（偶数）或者归一（奇数）时停止。**
     * 如果最短边是偶数（比如 2, 4, 6...），它不断减 2，最终正好等于 0。-> 没剩东西。
     * 如果最短边是奇数（比如 1, 3, 5...），它不断减 2，最终一定会等于 1。-> 剩下了“芯”。
2. 四边界收缩法