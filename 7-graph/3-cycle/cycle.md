> 有向图的环检测、拓扑排序算法。
* 进行拓扑排序之前，先要确保图中没有环。
* 图的「逆后序遍历」顺序，就是拓扑排序的结果。

# 环检测 | Digraph | 207
* 首先根据题意可知，课程的先修关系图中，只有没有互相依赖即成环的可能，就可以将课程全部修完
* 所以本质上是环检测算法
## DFS
* 想到可以使用遍历所有路径的方法来检测是否有图
  * 1、`onPath`数组记录当前递归路径中遇到的节点，如果重复遍历到同一个节点，说明有环
* 剪枝`Pruning`：使用`visited`记录节点是否之前被访问过
  * 2、如果节点不在 onPath 上，但 visited 是 true，说明这个节点在之前的某次搜索中已经作为入口被完整检测过了，并且确定是安全的（否则之前就报错了）。
  * 所以直接返回，不用再继续往下递归检测了
* 注意上面的判断顺序不能变，因为：
  * 如果一个节点构成了环，它必然是既被 visited 过，又在 onPath 上的。
  * 所以应该先检查环
  * 若未成环，再考虑剪枝的事情--为后续检测环优化时间
* 3、若本节点即不在路径上，也没被访问过，则开始检测
  * 入栈：标记 visited[src] = true（表示来过）和 onPath[src] = true（表示正在当前路径中）
  * 递归：对当前节点的所有邻居调用 dfs。
* 4、回溯：
  * 出栈：当所有邻居都遍历完且没发现问题，执行 onPath[src] = false。
  * 含义：我即将退出当前递归函数，从“当前路径”中移除我自己，以便父节点继续探索其他路径。
**每到一个节点：**

1. **我在当前死胡同里吗？** (onPath?) $\rightarrow$ 是环，**有毒！** ☠️
2. **我以前检查过是安全的吗？** (visited?) $\rightarrow$ 安全，**跳过！** ✅
3. **先把名字记在小本本上** (onPath = true)，然后去问邻居。
4. **邻居都没事？** 把名字从小本本上划掉 (onPath = false)，**撤退！** 🔙

## BFS
* BFS 算法借助 indegree 数组记录每个节点的「入度」
* 「出度」和「入度」是「有向图」中的概念，很直观：如果一个节点 x 有 a 条边指向别的节点，同时被 b 条边所指，则称节点 x 的出度为 a，入度为 b。
* 分析依赖关系
  * 入度=0的节点可以直接修，加入到BFS中的queu
  * 修完一个课程后，所以**它指向的节点**(*广度优先*)的入度-1，代表先修课程中已经修完了一门
    * 如果-1后入度变为0，则将这个节点也加入队列
  * 重复上面的操作，直到队列中没有元素
* 最后判断：如果存在节点没有被遍历，那么说明图中存在环
  * 所以遍历的过程中，需要记录遍历的节点个数
* 重要观察：
  * 按道理，图的遍历 都需要 visited 数组防止走回头路，
  * 这里的 BFS 算法其实是**通过 indegree 数组实现的 visited 数组的作用**，只有入度为 0 的节点才能入队，从而保证不会出现死循环。
# 拓扑排序 210
* Topological Sorting
  * 让你把一幅图「拉平」，而且这个「拉平」的图里面，所有箭头方向都是一致的，比如上图所有箭头都是朝右的。
  * 很显然，如果一幅有向图中存在环，是无法进行拓扑排序的，因为肯定做不到所有箭头方向一致；反过来，如果一幅图是「有向无环图」，那么一定可以进行拓扑排序。
  * ![alt text](top.jpg)
* 后序位置的代码是等到左右子树都遍历完才执行的，只有它才能体现出「**依赖**」关系，其他遍历顺序都做不到。
* 就是在前面环检测的代码中的，遍历的后续位置，添加本次访问到的节点
* 因为拓扑序必然需要包含所有的课程号，所以有了`visited`数组后，确保已经找过的节点不会再被加入到路径中，也就是如果图中有两条拓扑序 [0,1,2,3]/[0,2,1,3]，只会找到一个，但是不会受到另一种可能的影响
* 后序遍历记录节点的本质原因是“依赖关系的完全解析”（Dependency Resolution）
  * 也就是要将前面的路全部走完了，依赖关系打通了，无路可走了，我才开始记录结果
  * DFS 的后序遍历天然按照“出栈顺序”记录节点。 
  * 在依赖图中，“最没有依赖包袱”（也就是最底层的、最后修的）课程，会最先处理完并出栈。
  * 既然“最后修的课”最先进入列表，那么列表就是逆序的。所以我们需要把它反转回来，变成顺序。