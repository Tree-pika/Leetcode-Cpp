# 总述
>专门针对「动态连通性」的算法，这个算法的考察频率高，必须掌握。
* 并查集（Union Find）结构是二叉树结构 的衍生，用于高效解决**无向图**的连通性问题，可以在O(1)时间内**合并**两个连通分量，在O(1) 时间内**查询**两个节点**是否**连通，在O(1) 时间内查询连通分量的**数量**。
* 连通关系的性质
  * 1、自反性：节点 p 和 p 自身是连通的。
  * 2、对称性：如果节点 p 和 q 连通，那么 q 和 p 也连通。
  * 3、传递性：如果节点 p 和 q 连通，q 和 r 连通，那么 p 和 r 也连通。
* 判断这种「等价关系」非常实用，比如说编译器判断同一个内存对象的不同变量引用，比如社交网络中的朋友圈计算等等。
* 动态连通性问题就是说，给你输入一个图结构，然后进行若干次「连接操作」，同时可能会查询任意两个节点是否「连通」，或者查询当前图中有多少个「连通分量」。
* 设计一种数据结构，在尽可能小的时间复杂度下完成连接操作和查询操作。
```cpp
class UFNode {
    // 节点 id 编号
    int id;
    // 相当于指向父节点的指针
    int parent;
};

class UF {
private:
    // 记录连通分量
    int _count;
    // 节点 x 的父节点是 parent[x]
    vector<int> parent;
public:
    // 初始化并查集，包含 n 个节点，时间复杂度 O(n)
    UF(int n){
        // 一开始互不连通
        this->_count = n;
        // 父节点指针初始指向自己
        parent = vector<int>(n);
        for (int i = 0; i < n; i++)
            parent[i] = i;
    }

    // 连接节点 p 和节点 q，时间复杂度 O(1)
    void union_(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ)
            return;
        // 将两棵树合并为一棵
        parent[rootP] = rootQ;
        // parent[rootQ] = rootP 也一样

        // 两个分量合二为一
        _count--;
    }

    // 查询节点 p 和节点 q 是否连通（是否在同一个连通分量内），时间复杂度 O(1)
    bool connected(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        return rootP == rootQ;
    }

    // 查询当前的连通分量数量，时间复杂度 O(1)
    int count(){
        return _count;
    }

    // 查询节点 node 的根节点，时间复杂度取决于树的高度
    // 返回某个节点 x 的根节点
    int find(int x) {
        // 根节点的 parent[x] == x
        while (parent[x] != x)
            x = parent[x];
        return x;
    }
};
```
# 并查集的原理
* 本质上还是树结构的延伸。
* 想办法把同一个连通分量的节点都放到同一棵树中，把这棵树的根节点作为这个连通分量的代表，那么我们就可以高效实现上面的操作了。
* 并查集底层其实是一片森林（若干棵多叉树），每棵树代表一个连通分量：
  * connected(p, q)：只需要判断 p 和 q 所在的多叉树的根节点，若相同，则 p 和 q 在同一棵树中，即连通，否则不连通。
  * count()：只需要统计一下总共有多少棵树，即可得到连通分量的数量。
  * union(p, q)：只需要将 p 节点所在的这棵树的根节点，接入到 q 节点所在的这棵树的根节点下面，即可完成连接操作。注意这里并不是 p, q 两个节点的合并，而是两棵树根节点的合并。因为 p, q 一旦连通，那么他们所属的连通分量就合并成了同一个更大的连通分量。
* 并查集算法最终的目标，就是要尽可能降低树的高度，如果能保持树高为常数，那么上述方法的复杂度就都是 O(1) 了。
  * union 和 connected 方法的时间复杂度都依赖 find 方法，而 find 方法的时间复杂度取决于树的高度。
## 平衡树高
* 法一：在 union 方法中，总是将节点个数较少的树接到节点个数较多的树下面(确保不会进一步增加树高)
  * 可以保证最终树高在 O(logN) 级别，所以 union, connected, find 方法的时间复杂度都是O(logN)。
* 法二：路径压缩
  * 让树高始终保持在常数级别，这样 union, connected, find 方法的时间复杂度都是O(1)。
  * 路径压缩本身的均摊复杂度为O(1)

# 代码实现
* 用 parent 数组记录每个节点的父节点，相当于指向父节点的指针，所以 parent 数组内实际存储着一个森林（若干棵多叉树）。
* 普通实现的代码见上文
## 平衡优化1--用得多
* 用 size 数组记录着每棵树的重量，目的是让 union 后树依然拥有平衡性，保证各个 API 时间复杂度为 O(logN)，而不会退化成链表影响操作效率。
```cpp
class UF {
public:
    // 连通分量个数
    int count;
    // 存储一棵树
    vector<int> parent;
    // 记录树的「重量」/秩rank
    vector<int> size;

    // n 为图中节点的个数
    UF(int n) : count(n), parent(n), size(n, 1) {
        for (int i = 0; i < n; ++i) {
            parent[i] = i;
        }
    }

    // 将节点 p 和节点 q 连通
    void unionNodes(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) return;

        // 小树接到大树下面，较平衡
        if (size[rootP] > size[rootQ]) {
            parent[rootQ] = rootP;
            size[rootP] += size[rootQ];
        } else {
            parent[rootP] = rootQ;
            size[rootQ] += size[rootP];
        }
        // 两个连通分量合并成一个连通分量
        --count;
    }

    // 判断节点 p 和节点 q 是否连通
    bool connected(int p, int q) {
        return find(p) == find(q);
    }

    // // 返回节点 x 的连通分量根节点
    // int find(int x) {
    //     // 根节点的 parent[x] == x
    //     while (parent[x] != x)
    //         x = parent[x];
    //     return x;
    // }
    //平衡优化中也可以加入普通的路径压缩：这个只是查询的过程中一路迭代上去，将孙子节点挂到爷爷节点上
    int find(int x) {
        while (parent[x] != x) {
            // 进行路径压缩
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }

    // 返回图中的连通分量个数
    int countComponents() {
        return count;
    }
};
```
## 路径压缩
* 原理：并不在乎每棵树的结构长什么样，**只在乎根节点**。--父节点是谁等等不关心
  * 因为无论树长啥样，树上的每个节点的根节点都是相同的
* 在 find 函数中进行路径压缩，保证任意树的高度保持在常数，使得各个 API 时间复杂度为 O(1)。使用了路径压缩之后，可以不使用 size 数组的平衡优化。
```cpp
class UF {
private:
    // 连通分量个数
    int _count;
    // 存储每个节点的父节点
    vector<int> parent;

public:
    // n 为图中节点的个数
    UF(int n) {
        this->_count = n;
        this->parent.resize(n);
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }
    
    // 将节点 p 和节点 q 连通
    void union_(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        
        if (rootP == rootQ)
            return;
        
        parent[rootQ] = rootP;
        // 两个连通分量合并成一个连通分量
        _count--;
    }

    // 判断节点 p 和节点 q 是否连通
    bool connected(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        return rootP == rootQ;
    }

    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    // 返回图中的连通分量个数
    int count() {
        return _count;
    }
};
```