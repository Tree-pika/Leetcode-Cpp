# 347
* 分析题目要求
  * 统计不同数字/元素的出现频率: 借助 哈希表 来建立数字和其出现次数的映射，遍历一遍数组统计元素的频率
  * 对频率排序,找出前K个高频元素
    * bruce solution
      * selection sort:scan the whole map for k times,and for each time,save the biggest one to a vector and then kick it off from the map
      * time complexity:$O(n+k*n)$--worst case = $O(n^2)$
      * space complexity:O(m)--worst case = O(n)
    * using priority queue
      * 我们不需要对所有数据进行全排序，只需要维护一个大小为 $k$ 的“排行榜”。---维护一个元素数目为 k 的最小堆
      * 维护堆： 
        * 遍历哈希表，将(频率--元素)放入一个最小堆中。
        * 如果堆的大小超过了 $k$，就把堆顶（频率最小的那个）弹出来。
        * 这样，堆里始终保留的是当前频率最高的 $k$ 个元素。
      * 输出： 堆中的元素即为答案。
      * time complexity:
        * 堆的大小被限制在 $k$。
        * 插入和弹出操作的复杂度是 $O(\log k)$。
        * 要遍历 $m$ 个不同元素，总复杂度为 $O(m \log k)$。
        * 因为 $k \le n$，所以 $O(n \log k)$ 必定优于 $O(n \log n)$。
      * space complexity
        * $O(n)$用于哈希表
    * using bucket sort
      * 映射： 也是先用 Map 统计频率。
      * 桶： 创建一个数组（桶），下标代表频率。
        * 因为一个元素出现的次数最多是 $n$ 次（$n$ 是数组大小），所以桶的大小只需要 $n+1$。
        * bucket[i] 里存放所有“出现次数为 $i$”的数字。
      * 倒序取值： 从后往前（频率从大到小）遍历桶，把桶里的数字拿出来，直到凑够 $k$ 个。
      * 时间复杂度： $O(n)$。
        * 遍历 nums 统计频率：$O(n)$
        * 遍历 Map 填桶：$O(n)$ (因为 Map 大小 $\le n$)
        * 遍历桶收集结果：尽管有两层循环，但每个数字最多只被访问一次，总次数约为 $O(n)$。
      * 空间复杂度： $O(n)$。
        * Map 存储所有元素 $O(n)$。
        * Buckets 数组存储所有元素 $O(n)$。
    * 其他
      * 使用哈希表cnt统计完频率后的排序，做题时还有个思路，就是将cnt的频率部分提取出来，使用一个vector<int> freq;装这些频率，然后使用ranges::sort(freq);来排序，这样就知道了前k大频率是什么，然后遍历哈希表cnt：
      * ``` cpp
        vector<int> res;
        int i=0;
        for(auto &[k,v]:cnt){
          if(v==freq[i++])
            res.push(k);
        }
      * 上面这种**不对**，发现还是要对于每一个vector[i](i=0-k-1)去遍历一遍cnt，时间复杂度相比Bruce solution并没有优化
      * 所以本质原因就是：在哈希表里面搜索val是一件效率不高的事情


