# 代码复用
> 232

* 在工业级别代码开发中，最忌讳的就是 实现一个类似的函数，直接把代码粘过来改一改就完事了。
* 这样的项目代码会越来越乱，一定要懂得复用，功能相近的函数要抽象出来，不要大量的复制粘贴，很容易出问题！

# 20
* 要从整体的角度考虑问题
* 不要去预判下一个字符是什么
* 只需要一次遍历，遇到左括号就压栈，遇到右括号就出栈，如果此时栈为空或者栈顶字符不匹配，说明不是有效的括号。
* 最后，若栈不为空，说明还有左括号没闭合，报错。
* 改进：
  * 上述判断匹配还需要新开一个函数，否则写在循环里面比较麻烦
  * 所以一个转化的技巧就是：遇到左括号就将对应的右括号压栈，遇到右括号：
    * 栈为空，return false
    * 栈顶字符与此时右括号不相等--相等很容易判断，return false
    * 相等：出栈
  * 最后，若栈不为空，说明还有左括号没闭合，报错
    * 不用写下面的`if-else`判断：
    * ```cpp
        if(ans.empty()){
        return true;
        }
        return false;
    * 直接一句`return ans.empty();`
* 越界注意：
  * 永远不要在循环里无保护地访问 i+1(i=n-1)时会发生数组越界访问
* 【待完成】栈在系统中的应用：71. 简化路径；Linux的cd命令

# 1047
* 每次先判断栈是否为空
* 然后判断栈顶字符是否与当前字符相同
* 相同则出栈，同时跳过本字符
* 不相同则压栈本字符
* 最后栈中剩下的就是变换后的字符串:需要先出栈再反转
* 也可以直接将最终的字符串作为一个栈，因为字符串支持栈的所有操作：
  * `stack`->`string`
  * `pop`->`pop_back`
  * `push`->`push_back`
  * `top`->`back`
* 题外话
  * 在企业项目开发中，尽量不要使用递归！在项目比较大的时候，由于参数多，全局变量等等，使用递归很容易判断不充分return的条件，非常容易无限递归（或者递归层级过深），造成栈溢出错误（这种问题还不好排查！）
  
# 逆波兰表达式
1. 逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。
* 平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。
* 该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。
2. 逆波兰表达式主要有以下两个优点：
* 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。
* 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中
3. 表达式树（Expression Tree）
* 任何一个算术表达式，都可以转化成一棵二叉树：
  * 叶子节点（最底层的节点）：是操作数（数字）。
  * 非叶子节点（中间的节点）：是运算符（$+, -, *, /$）。
* 核心逻辑：一个运算符节点，操作的是它的左子树结果和右子树结果。
4. 举个例子：
* $(3 + 4) * 5$这个表达式的最后一步运算是乘法 $*$。
* $*$ 的左边是 $(3 + 4)$，右边是 $5$。
* $(3 + 4)$ 的核心是 $+$，左边 $3$，右边 $4$。
* 画成树就是这样：
* ```
      *
     / \
    +   5
   / \
  3   4
5. 三种遍历方式在“表达式树”上的含义
* 中序遍历 (Left $\to$ Root $\to$ Right)：
  * 先访问左子树 $\to$ 再访问根（运算符） $\to$ 再访问右子树。
  * 在上面的树中：先访问左边 $(3+4)$，再访问 $*$，再访问 $5$。
  * 结果：3 + 4 * 5。
  * 结论：中序遍历得到的是中缀表达式（也就是我们要加括号才能看懂的普通数学表达式）。
* 前序遍历 (Root $\to$ Left $\to$ Right)：
  * 先访问根（运算符） $\to$ 左 $\to$ 右。
  * 结果：* + 3 4 5。
  * 结论：前序遍历得到的是波兰表达式（前缀表达式）。
* 后序遍历 (Left $\to$ Right $\to$ Root)：
  * 规则：先遍历左子树，再遍历右子树，最后访问根节点。
  * 在树上的路径：先去左子树 + 那边。在 + 子树里，先左 3，再右 4，最后根 + $\to$ 输出 3 4 +。
  * 搞定左边后，去大树的右子树 5 $\to$ 输出 5。
  * 左右都搞定了，最后访问大树的根 * $\to$ 输出 *。
  * 最终结果：3 4 + 5 *。
  * 这正是逆波兰表达式（后缀表达式）
6. 逆波兰表达式是用后序遍历的方式把二叉树序列化了
7. 对计算机友好：从前往后依次顺序遍历即可，而中序表达式计算机需要回退判断优先级等。

# 150
* 对于一个波兰表达式，遇到操作数就压栈
* 遇到一个算符就从栈中弹出两个操作数进行操作，注意先弹出来的应该是操作数2，计算结果后将结果压栈
* 注意因为计算时、最后返回的结果都要求是整型数字，所以为了方便，直接每次压栈的时候都先用下面介绍的字符串转换函数将`string`转换为对应的`int/long long`等，再压栈。
# 字符串转化函数


### 1\. 函数族用法

#### 通用原型

```cpp
T std::stoX(const std::string& str, size_t* idx = nullptr, int base = 10);
```

  * **`str`**: 待转换的字符串（会自动忽略前导空格，直到遇到非数字字符停止）。
    * 跳过前导空格（如果有）。
    * 检查是否有正负号（+ 或 -），如果有，记录符号，指针后移。
    * 开始读取数字（0-9）。
  * **`idx`**: **(可选)** 指针。函数执行后，该位置会存储**第一个未进行转换的字符的下标**（用于截取剩余字符串）。
  * **`base`**: **(可选)** 进制，默认为 10。若设为 0，则根据前缀（`0x`, `0`）自动推断。
      * *注：浮点型转换函数（stof/stod/stold）通常不包含 base 参数。*
      * 进制用于判断哪些字符为数字字符（本系列函数可以转换的部分），若为10，只有`'0'-'9'`可以被转换；若为16，则`'0'-'9'/'a'-'f'/'A'-'F'`都可以被转换。

#### 具体函数对照表

| 函数名 | 返回类型 (T) | 说明 |
| :--- | :--- | :--- |
| **`stoi`** | `int` | 转为 `int` |
| **`stol`** | `long` | 转为 `long` |
| **`stoll`** | `long long` | 转为 `long long` |
| **`stoul`** | `unsigned long` | 转为 `unsigned long` |
| **`stoull`** | `unsigned long long` | 转为 `unsigned long long` |
| **`stof`** | `float` | 转为 `float` |
| **`stod`** | `double` | 转为 `double` |
| **`stold`** | `long double` | 转为 `long double` |

-----

### 2\. 异常处理机制

与 C 语言的 `atoi` 不同（失败仅返回 0），`std::stoX` 系列会**抛出异常**，需使用 `try-catch` 捕获：

| 异常类型 | 触发场景 | 示例 |
| :--- | :--- | :--- |
| **`std::invalid_argument`** | 在跳过前导空格后，字符串无法匹配 [可选的正负号] + [至少一个数字] | `stoi("hello")` |
| **`std::out_of_range`** | 转换结果超出了目标类型的范围 | `stoi("99999999999")` (超 int 范围) |

#### 典型代码示例

```cpp
#include <string>
#include <iostream>

try {
    std::string s = "123hello";
    size_t idx;
    int num = std::stoi(s, &idx); // num = 123, idx = 3 ('h'的位置)
} 
catch (const std::invalid_argument& e) {
    std::cout << "错误：非数字输入" << std::endl;
} 
catch (const std::out_of_range& e) {
    std::cout << "错误：数值溢出" << std::endl;
}
```