# 单调队列monotonic queue
* 维护元素单调递减的队列就叫做单调队列，即单调递减或单调递增的队列。C++中没有直接支持单调队列，需要我们自己来实现一个单调队列
* 设计需求：
  * 每次窗口移动的时候，调用出队que.pop(滑动窗口中移除元素的数值)，入队que.push(滑动窗口添加元素的数值)
  * que.front()返回最大值：靠出队和入队的逻辑来维系
* 设计思路
  * `push(value)`：为了确保出队的队头元素是最大值，我们入队**前**需要判断：
    * `value`来自滑动窗口中的新增值
    * 当`value`小于等于队尾的时候，直接`push`到队尾即可；
    * 当`value`大于队尾的时候，需要持续`pop_back`直到队尾大于`value`，然后再`push`到队尾
  * `pop`
    * 我们控制的循环是滑动窗口不断在走，所以每次希望`pop`的也是**上一次窗口最左边的值**。
    * 但是因为上面`push`的操作，所以对于不是上一次窗口中的最大值的值：
    * 1、可能在最大值入队时，被`pop`走了，这里不需要再重新`pop`
    * 2、比最大值入队晚，但是后续`push(new_value)`的时候要么和前面的最大值一起被`pop`走，要么夹在中间，最大值还是原来那个，总之不影响下一轮最大值的判断，所以也不用去`pop`：而且`pop`很麻烦，因为它不在队首，我们`pop`之后还得将队首再`push`进来。分析完不`pop`也没影响后，就直接不用管了。
    * 综上：每次`pop`时先判断窗口最左边的值是否等于队列中的`front`，如果是，就出队；否则不用管。
* pitfalls
  * 单调队列不是一成不变的，而是不同场景不同写法
* 239
  * 应用到本题的思路：上述的就是针对本题场景的单调队列的设计思路
  * 时间复杂度：nums 中的每个元素最多也就被 push_back 和 pop_back 各一次，没有任何多余操作，所以整体的复杂度还是 O(n)。
  * 空间复杂度：因为我们定义一个辅助队列，所以是O(k)。
  * 【待完成】：本题是难题，涉及到“单调队列”一系列题目，可以在leetcode中题解中找到
  * solution2：
    * 使用multiset作为单调队列
