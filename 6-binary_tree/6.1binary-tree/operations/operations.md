# 226
* 反转二叉树
* ![镜像二叉树](20717714d97fa04d509e4f0525a3089efefc2ea02cc08ce92b77978e9b51f15f-Picture1.png)
* 只需要对于每一个节点，交换其左右孩子即可，至于访问节点的顺序，无所谓，但要保证同一个节点只能反转一次。
* 涉及到遍历所有节点，两种选择
  * DFS：递归法和迭代法都可以
    * 前序遍历:
      * 递归就是先处理根节点，然后接下来想要先处理左孩子，再处理右孩子，这是我需要交给计算机去做的事情，所以调用递归来完成。
      * 迭代：使用前序遍历的模板即可，处理完根节点后，还是先压栈右孩子，再压栈左孩子，确保弹栈处理时先处理的是左孩子
        * 但其实这里只要能正确遍历即可，所以先压栈左孩子也可以
    * 后序遍历
      * 递归：左->右->根，思路同前序
      * 迭代：暂时不写
    * 中序遍历
      * 需要注意因为对根节点的处理夹在处理左右节点的中间，所以会导致原来的右孩子经过这一步后被交换到左孩子，所以在第三步处理右孩子的时候，传进入的参数应该是此时root的left
  * BFS：层序遍历，迭代法
* 迭代：BFS层序遍历的思路
  * 不过可以优化的点：不需要关心当前是第几
  * 使用队列先进先出，每次用完及时pop可以保证每个节点有且仅被遍历一次