# depth
* 使用迭代法
* 利用层序遍历的模板
  * 只不过不需要在遍历的时候按序保存节点的值了
* 最大深度
  * 初始化level = 0；
  * 每遍历一层level++
* 最小深度
  * 依次遍历每一层，每遍历一层就level++
  * 但是遍历每一层的每一个节点的时候，注意若发现该节点是叶子节点，就直接return level；
    * leaf node判断：`if(!root->left&&!root->right)`
* 也可以使用递归
  * 二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）
  * 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数或者节点数（取决于高度从0开始还是从1开始）
  * leetcode的题目中都是以节点为一度，即根节点深度是1。
  * 若用后序递归，即先求本节点左右子树的**高度**，再+1成为本节点的高度
    * 利用根节点的高度 = 树的最大**深度**
  * 【待完成】若用前序递归：求的就是本节点的深度
# symmetric & 101 & 100
* 对称二叉树定义： 对于树中 任意两个对称节点 L 和 R ，一定有：
  * ![alt text](1599398062-PbkpuX-Picture1.png)
  * L.val = R.val ：即此两对称节点值相等。
  * L.left.val = R.right.val ：即 L 的 左子节点 和 R 的 右子节点 对称。
  * L.right.val = R.left.val ：即 L 的 右子节点 和 R 的 左子节点 对称。
* 递归法求解
  * 只需要考虑三层的树结构即可：root-孩子-孙子
    * root与孩子的这两层需要我们自己动手写代码判断
    * 后续继续判断孙子层，可以看作是孩子与它的孩子，是我们希望计算机去做的事情，使用递归即可
  * 拿上图举例，若tree中无节点，直接返回true即可(但是题目提示节点数>=1，所以本题可以不用考虑)
  * 拿到一个root，先判断其左右孩子的值是否相等
    * 但是前提是有左右孩子
    * 所以对于第二层的判断
      * 1、先判断left child/right child是否为空
      * 2、确保都不为空的情况下，判断值是否相等
    * 进入第三层的判断：
      * 内侧是否对称：判断左孩子的右子树与右孩子的左子树是否相等(前提也是先判断是否为空，但这个就是我们希望计算机帮我们做的事情，调用递归即可)
      * 外侧是否对称：判断左孩子的左子树与右孩子的右子树是否相等
    * 只有内外侧都对称的情况下，我们才可以判断整棵树是对称的

# 222-nodeSum
## general solution
> 没有考虑到complete binary tree的性质
* 递归法：postorder，先分别计算左右子树的节点数，然后相加后+1(算上root)
  * 时间复杂度：O(n)
  * 空间复杂度：O(log n)，算上了递归系统栈占用的空间
* 迭代法
  * 层序遍历

## complete BT
* 拆解complete binary tree,找到可以递归的共同点
  * 情况一：就是满二叉树
    * 对于情况一，可以直接用 2^树深度 - 1 来计算，注意这里根节点深度为1。
  * 情况二：最后一层叶子节点没有满。
    * 对于情况二，分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况1来计算。
* 判断binary tree是否perfect
  * 在**完全二叉树**中，如果递归向左遍历的深度等于递归向右遍历的深度，那说明就是满二叉树。
  * ![alt text](20220829163709.png)

# backtrace & 257
* 学会break down a big problem into many smaller problems
  * 结果保存问题：没必要边遍历边控制结果的格式，可以先同一加载数据`node->val`到`vector<int> path;`中，然后从这个中间结果将最终结果加载出来，这样两次转换都比较好想且丝滑
* 递归法：
  * 传入引用，直接修改外部变量path
  * 前序遍历：先加入根节点到路径中，然后分别去左右子树中找路径
    * 每次单层递归添加到路径中就一个根节点
    * 所以去子树中找路径时，每次递归也就添加了左孩子/右孩子(可以看作是它们所在子树的根节点)，调用回来从路径中将左孩子/右孩子pop出去，实现回溯的思路
  * 时间复杂度：$O(n^2logU)$，其中 n 是二叉树的节点个数，U 是节点绝对值的最大值。最坏情况下，二叉树是扫帚形，即一条 O(n) 个节点的链加上一棵包含 O(n) 个叶子的（完全）二叉树。在这种情况下，由于每个节点值的字符串的长度为 O(logU)，所以路径长度为 O(nlogU)。我们会把 O(n) 个长为 O(nlogU) 的 path 加入答案。
  * 空间复杂度：O(nlogU)。返回值不计入。path 需要 O(nlogU) 的空间。
* 递归法2
  * 值传递path
  * 隐式回溯：执行 dfs(node->left, path) 时，父节点的 path 并没有改变，改变的是传给子节点的那个“副本”。
    * 当子函数运行结束并返回时，父函数里的 path 还是它原来的样子。这种利用局部变量保存状态的行为，就是隐式回溯。
  * 时间复杂度：$O(n^2logU)$，其中 n 是二叉树的节点个数，U 是节点绝对值的最大值。最坏情况下，二叉树是扫帚形，即一条 O(n) 个节点的链加上一棵包含 O(n) 个叶子的（完全）二叉树。在这种情况下，由于每个节点值的字符串的长度为 O(logU)，所以路径长度为 O(nlogU)。我们会把 O(n) 个长为 O(nlogU) 的 path 加入答案。
  * 空间复杂度：$O(n^2logU)$。所有 path 加起来一共需要 $O(n^2logU)$ 的空间。
* 统一性能优化：利用lambda表达式
  * `[&]`（捕获列表）： 这里的 & 表示按引用捕获。这意味着 Lambda 内部可以直接使用和修改**外部定义的变量**，比如 ans 和 path。
  * `-> void`尾置返回类型（Trailing Return Type）:增强代码可读性和严谨性(虽然lambda通常可以自动推导返回类型)

  * lambda类型`auto name=[](parameter){//function body};`
    * 必须写 `auto`：因为 Lambda 的实际类型是编译器自动生成的匿名类，人类无法写出它的名字，只能通过 auto 让编译器去推导。
  * `this auto &&dfs`:C++23实现自我递归的高效写法--利用`this`
    * 将 Lambda 闭包对象本身作为第一个参数传入。
    * 后续调用过程中不用再传入此参数
    * `auto&&`万能引用（Universal Reference）:既能接收左值也能接收右值。
* 【待完成】迭代法

# 543
* 一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了。
* 只有后序位置才能通过返回值获取子树的信息。
* 每一条二叉树的「直径」长度，就是一个节点的左右子树的最大深度之和。
* 遍历整棵树中的每个节点，然后通过每个节点的左右子树的最大深度算出每个节点的「直径」，最后把所有「直径」求个最大值即可。

# 236 Lowest Common Ancestor | LCA
* 问题引入
  * git pull -r：会使用 rebase 的方式将远端修改拉到本地。
  * ![alt text](1.jpg)
  * 首先，找到这两条分支的最近公共祖先 LCA，然后从 master 节点开始，重演 LCA 到 dev 几个 commit 的修改，如果这些修改和 LCA 到 master 的 commit 有冲突，就会提示你手动解决冲突，最后的结果就是把 dev 的分支完全接到 master 上面。
* 题目分析
  * 