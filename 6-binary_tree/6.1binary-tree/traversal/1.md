# DFS|stack|144 & 145 & 94
* analyze the input:$root = [1,null,2,3]$
  * 这就是用数组实现顺序存储树节点的表示方法
  * 从上到下，层序遍历，从左到右，依次将树的节点的值存入数组中
  * 节点不存在就存null
  * 数组的索引从0开始，因此若父节点的索引为$i$，其左孩子索引为$2*i+1$，右孩子的索引为$2*i+2$
* analyze the output
  * 可以看到输出结果里面并没有null
  * 说明我们后面在遍历节点的时候，空间点不要保存进结果
* solution
  * recursion
    * 判断什么时候结束：全部遍历完即cur==nullptr时返回
    * 每次递归要做什么：将root->val保存到vector中，然后遍历它的左孩子和右孩子--利用递归告诉计算机这一点就好
    * 所以三种顺序的遍历，只需要将`vec.push_back(cur->val);`的顺序换来换去即可：放最前面/中间/最后面。
    * time complexity：$O(N)$,其中 N 是二叉树的节点数。每一个节点恰好被遍历一次。
    * space complexity:$O(N)$,为递归过程中栈的开销，平均情况下为 $O(logN)$，最坏情况下树呈现链状，为 $O(N)$。
      * 所以其实linked list可以看作是单叉树
  * iteration
    * 模拟系统栈，自己显式使用`stack<TreeNode *> st`来模拟树节点访问过程中的压栈，并在特定的条件下进行弹栈
    * preorder
      * 压栈root，然后弹出
      * 接着先压栈right child，再压栈left child
      * 这样出栈的顺序就是(root->)left->right
    * postorder
      * 因为要求的顺序是left->right->root
      * 想到reverse就变成了root->right->left
      * 而想要得到这个次序的结果，只需要模拟preorder的写法，然后压栈的时候先压栈left child，再压栈right child即可
    * inorder
      * 比较复杂，原因在于最先访问到的是根节点，但是要先等访问并处理完其左子树，才可以处理根节点
      * 处理左子树：一路往左访问，并压栈path中的node
      * 等到cur==nullptr时，说明已经访问到树的最左底边，即刚刚压栈的node是最左的node，它没有left child了
      * 所以先处理这个node`vec.push_back(st.top()->val);`,然后访问其右子树
      * time complexity：$O(N)$,其中 N 是二叉树的节点数。每一个节点恰好被遍历一次。
      * space complexity:$O(N)$,为递归过程中显式栈的开销，平均情况下为 $O(logN)$，最坏情况下树呈现链状，为 $O(N)$。
  * 线索二叉树Threaded Binary Tree：Morris遍历
    * inorder
      * 中序复杂的原因就在于处理完左边的node之后，要返回到之前访问过的root继续处理
      * 在前面两种方法中，都是用的栈来保存这个已访问过的root node(recursion-system stack；iteration-stack in stl)
      * 但若将这个访问的顺序信息直接记录在binary tree中，就不用使用栈了
    * Morris的核心思想：利用叶子节点（Left Subtree's Rightmost Node/Right Substree's Leftmost Node）大量的空闲指针 (right == NULL/left==NULL)，指向当前节点的后继（Back to Root），从而省去栈的空间。
    * time complexity：$O(N)$
    * space complexity:$O(1)$
    * 于是引入线索二叉树的概念：
      * 一些定义
        * 前驱节点 (Predecessor) ：对于当前节点 cur，其左子树中最右边的节点（在中序遍历中，它是 cur 的前一个节点）。
        * 后继节点：在中序遍历中，它是 cur 的后一个节点。
    * 理解：Morris 遍历本质上是一个“会回到原点”的过程。
      * 对于**有左孩子的父节点**，我们会经过它两次：
        * 第一次到达：刚从它的父节点下来。
        * 第二次到达：遍历完它的左子树后，通过线索（前驱的 right 指针）又回到了它。
      * preorder
        * 如果 root 没有左孩子：直接打印 root。
        * 如果 root 有左孩子：在搭桥（建立线索） 的瞬间，打印 root。因为这是我第一次见到它，还没去它的左边呢。
      * inorder
        * 如果 root 有左孩子，第一次见到它时不打印root，先去遍历左边。等左边都跑完了，顺着线索第二次回到 root 时，才打印它。
        * 如果 root 没有左孩子，说明不需要等待，直接打印。
      * postorder
        * 后序遍历的顺序是：左 -> 右 -> 根。
        * 反转后：根 -> 右 -> 左 其实就是“镜像版”的前序遍历
        * 如果 root 没有右孩子：直接打印 root。
        * 如果 root 有右孩子：在搭桥（建立线索） 的瞬间，打印 root。因为这是我第一次见到它，还没去它的右边呢。

# BFS|queue|102
* 队列先进先出，符合一层一层遍历的逻辑
* 按层打印： 题目要求的二叉树的 从上至下 打印（即按层打印），又称为二叉树的 广度优先搜索（BFS）。BFS 通常借助 队列 的先入先出特性来实现。
*  每层打印到一行： 将本层全部节点打印到一行，并将下一层全部节点加入队列，以此类推，即可分为多行打印。
*  上面的解法显然是iteration
   *  时间复杂度：每个节点进队出队各一次，故渐进时间复杂度为 O(n)。
   *  空间复杂度：队列中元素的个数不超过 n 个，故渐进空间复杂度为 O(n)。
*  也可以用递归来写，用的就是DFS的思路了
   * 使用前序遍历（根 -> 左 -> 右）。这样能保证我们在每一层中，都是先访问左边的节点，再访问右边的节点，从而满足“从左到右”的要求。
   * 递归函数需要一个参数 level 来记录当前节点所在的深度（从 0 开始）。
   * 当我们访问到的 level 等于结果列表 res 的长度时，说明我们第一次到达了这一层，需要在 res 中加入一个新的空数组。
   * 将当前节点的值加入到 res[level] 中。
   * 时间复杂度： 
      *  $O(N)$每个节点都会被访问且仅被访问一次。
   * 空间复杂度： $O(H)$
     * $H$ 是树的高度。这是递归栈的开销。
     * 如果树退化成链表，空间复杂度为 $O(N)$。
     * 注意：这里不计算存储最终结果所需的空间。