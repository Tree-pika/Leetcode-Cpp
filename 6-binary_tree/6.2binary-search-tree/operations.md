* 实现 BST 的基础操作：判断 BST 的合法性、增、删、查。其中「删」和「判断合法性」略微复杂。
* BST 的基础操作主要依赖「左小右大」的特性，可以在二叉树中做类似二分搜索的操作，寻找一个元素的效率很高。
* 常见框架
  ```cpp
  void BST(TreeNode* root, int target) {
    if (root->val == target)
        // 找到目标，做点什么
    if (root->val < target) 
        BST(root->right, target);
    if (root->val > target)
        BST(root->left, target);
  }

# 98 validate
* 开始的错误思路：对于每一个节点比较左子树是否比自己小，右子树是否比自己大；然后递归地先判断左子树的节点，再判断右子树的节点
  * 这样对于非BST = [5,4,6,null,null,3,7]，我们会判true
  * 原因在于没有满足本节点除了要和父节点的大小关系正确，也要与一直到根节点的所有祖先节点大小关系正确
* BST 的每一个节点不仅要和它的直接父节点比较，还要遵守祖先们定下的规矩。
  * 向左走：你必须比父节点小，但同时通过父节点继承了爷爷、太爷爷给父节点的下限。
  * 向右走：你必须比父节点大，但同时通过父节点继承了爷爷、太爷爷给父节点的上限。
* isValidHelper用于判断：这棵子树的所有节点，是否都落在 (min, max) 这个开区间内
  * 所以关键思路变了：原本错误思路是向下判断子节点是否符合与自己的大小关系
  * 但由于树是往下遍历的，所以当前层只能判断父子两代的关系
  * 我们现在变为向上判断，本节点是否满足所有祖先节点的要求，树是往下遍历的，所以我的所有祖先节点现在必定已经遍历过了，这就保证了判断的完整性
  * 对于初始情况`root`
    * nullptr 明确表示“无限制”
    * 无祖先，就无限制
  * 时间复杂度: $O(N)$。
    * 因为每个节点我们只访问了一次，进行了常数次比较。
  * 空间复杂度: $O(H)$。$H$ 是树的高度。
    * 这是因为递归调用栈的深度。
    * 最坏情况（退化成链表）：$O(N)$。
    * 平均情况（平衡树）：$O(\log N)$。