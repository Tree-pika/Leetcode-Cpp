# 230
* 时间复杂度 (Time Complexity): $O(N)$。
  * 在最坏的情况下（例如树退化成链表，或者 $k=N$），我们需要遍历整棵树。
  * 平均情况下是 $O(H + k)$，其中 $H$ 是树的高度。因为我们一旦找到第 $k$ 个就停止了。
* 空间复杂度 (Space Complexity): $O(H)$。
  * 这里的 $H$ 是树的高度。这是因为递归调用栈 (Recursion Stack) 的深度取决于树的高度。
  * 如果是平衡树，$H = \log N$；
  * 最坏情况是 $N$。
* 在 C++ 工程实践中，为了代码的清晰和避免上述的返回值陷阱，我们通常会将 “对外接口” 和 “内部递归逻辑” 分开。
* 以输入：root = [5,3,6,2,4,null,null,1], k = 3为例分析剪枝的优化过程
```markdown
0、我们定义当前状态为：inorder(当前节点, k)。 初始状态：cnt = 0, res = -1。
1、第一阶段：一路向左 (压栈)
1. inorder(5, 3) 被调用。
  ○ 不为空。
  ○ 遇到 inorder(node->left)，准备去 3。
  ○ 【暂停 5，进栈】
1. inorder(3, 3) 被调用。
  ○ 不为空。
  ○ 遇到 inorder(node->left)，准备去 2。
  ○ 【暂停 3，进栈】
1. inorder(2, 3) 被调用。
  ○ 不为空。
  ○ 遇到 inorder(node->left)，准备去 1。
  ○ 【暂停 2，进栈】
1. inorder(1, 3) 被调用。
  ○ 不为空。
  ○ 遇到 inorder(node->left)，左孩子是空 (nullptr)。
  ○ 调用 inorder(nullptr) -> 直接 return。
2、第二阶段：触底反弹与计数 (出栈)
此时我们在 节点 1 的函数体内。
● 节点 1 继续执行：
  ○ 检查剪枝：cnt(0) >= 3? 否。
  ○ 中序位置 (关键点)：cnt 自增，cnt 变为 1。
  ○ 检查 cnt == k? (1 == 3) 否。
  ○ 递归右孩子：inorder(nullptr) -> 直接 return。
  ○ 节点 1 执行完毕，return。
回到 节点 2 的函数体内（从刚才暂停的地方继续）：
● 节点 2 继续执行：
  ○ 检查剪枝：cnt(1) >= 3? 否。
  ○ 中序位置：cnt 自增，cnt 变为 2。
  ○ 检查 cnt == k? (2 == 3) 否。
  ○ 递归右孩子：inorder(nullptr) -> 直接 return。
  ○ 节点 2 执行完毕，return。
回到 节点 3 的函数体内：
● 节点 3 继续执行：
  ○ 检查剪枝：cnt(2) >= 3? 否。
  ○ 中序位置：cnt 自增，cnt 变为 3。
  ○ 检查 cnt == k? (3 == 3) 是！
  ○ 【锁定答案】：
    ■ res = node->val (即 res = 3)。
    ■ 执行 return。
3、第三阶段：剪枝生效 (光速撤退)
回到 节点 5 的函数体内（节点 3 刚刚返回）：
● 节点 5 继续执行：
  ○ 【剪枝检查】：代码行 if(cnt >= k) return;
  ○ 此时 cnt 是 3，k 是 3。条件成立！
  ○ 直接 return！
  ○ 注意：这里非常关键。因为这个剪枝，节点 5 自己的值没有被处理，节点 5 的右子树（节点 6）根本没有被访问。这就是优化的力量。
最终结果
主函数 kthSmallest 收到 inorder 的结束信号，返回 res，即 3。
```
