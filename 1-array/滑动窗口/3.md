# 滑动窗口
> 也是一种双指针法

1. 滑动窗口的思想是：维护一个窗口 [left, right]，这个窗口像一条毛毛虫一样在数组上蠕动：
* 进食（Expand）： right 指针向右走，吃进数字，让 sum 变大。
* 消化（Shrink）： 当 sum >= target（吃饱了），我们就尝试缩短身体，让 left 指针向右走，吐出数字，**看能不能在保持“吃饱”的前提下，让身体变短。**
* 在收缩之前，这个最短记录我们已经记下来了；且要求是连续的子数组，所以必定是需要抛掉子数组中最左边的元素。

2. 时间复杂度的分析
* 观察指针的移动次数：
  * right 指针：从 0 走到 N-1，一共走了 $N$ 步。
  * left 指针：虽然是在 while 里，但它也只能往右走，不可能往回退。
  * 最坏的情况也就是从 0 走到 N-1，一共 $N$ 步。
* 总操作次数：
  * 每个元素最多被 right 访问一次（加法），被 left 访问一次（减法）。
  * 总时间复杂度是 $O(2N)$，即 $O(N)$。
* 相比暴力解法的优势：
  * 暴力解法中，每次外层循环 i 变动时，内层循环 j 都要重新从头开始累加 sum。这做了很多重复工作。
  * 暴力解法是“固定起点，遍历终点”
  * 滑动窗口是“动态调整起点和终点，永不回头”：即起点在每次遍历时也是可以移动的，而非需要再次进入循环才固定为一个新值。

3. 具体题目的分析
   * 209：
   * 定义两个指针：left（窗口左边界）和 right（窗口右边界）。

        - 初始化 left = 0，sum = 0，minlen = INT_MAX（或者 nums.size() + 1）。

        - 让 right 从 0 开始遍历整个数组（外层循环）：

          - 将 nums[right] 加入 sum。

        - 关键点：当 sum >= target 时（内层循环，注意这里是 while 不是 if）：

          - 说明当前窗口 [left, right] 是合法的。

          - 尝试更新 minlen（当前长度为 right - left + 1）。

          - 尝试缩小窗口：将 nums[left] 从 sum 中减去，并将 left 向右移一步 (left++)。

          - 继续检查 sum 是否还大于等于 target，如果是，继续缩，直到 sum < target 为止。

        - 如果 sum < target，跳出 while，回到外层循环，继续让 right 往右走去找新的数字。
   * 904
     * 滑动窗口：
       * 左右指针
       * 右指针一直往右挪，以增加sum/水果数目，直到不满足某个条件（本题是水果种类大于2时）
       * 进入一个循环，开始挪左指针，即窗口起点
       * 左指针也是从左往右开始逐一扔掉水果，即`val`,等到再次满足条件时，就出循环，继续往右挪右指针，增加水果数目
         * 如果是用哈希表记录每种水果的数量，则须注意，当这类水果全部被扔掉的时候，需要将整个键值对`key-value`从哈希表中删除。
     * 细节优化
    ``` cpp
    int num = fruits[left];
    cnt[num]--;         // 第1次查找：计算 num 的哈希值，找到位置，修改
    if(cnt[num]==0){    // 第2次查找：再次计算 num 的哈希值，找到位置，读取
        cnt.erase(num); // 第3次查找：再次计算 num 的哈希值，找到位置，删除
    }
    /*method2*/
    auto it = cnt.find(fruits[left]); // 第1次查找：计算哈希，返回迭代器（指针）
    --it->second;                     // 直接通过指针操作内存，无哈希计算，O(1)
    if (it->second == 0) {
        cnt.erase(it);                // 直接删除迭代器指向的元素，无哈希计算，O(1)
    }
    ```
     * operator[] 每次调用都会执行一次哈希查找。
     * 用迭代器 it 暂存查找结果速度更快。
     * 数据结构优化
       * 可以用数组代替哈希表