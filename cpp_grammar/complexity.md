总结一套专门用于 LeetCode 刷题的**实战分析法**。

------



### 第一部分：如何分析时间复杂度 (Time Complexity)



时间复杂度不是代码运行的绝对时间（秒），而是**代码执行次数随数据规模 $N$ 增长的变化趋势**。我们关注的是**最坏情况**（Big O）。



#### 1. 基础法则：数循环



这是最直观的方法。看代码里的 `for` / `while` 循环。

- $O(1)$ 常数级：

  没有循环，或者循环次数是固定的（比如 for(int i=0; i<26; i++) 遍历字母表）。

  - *场景：* 哈希表查找、数组下标访问、简单的数学计算。

- $O(N)$ 线性级：

  一层循环，从 0 遍历到 $N$。

  C++

  ```
  for(int i = 0; i < n; i++) { ... }
  ```

  - *场景：* 遍历数组、链表、双指针（虽然两个指针动，但每个元素最多被访问常数次）。

- $O(N^2)$ 平方级：

  双层嵌套循环。刚才你的方案三（BF算法）就是典型的例子。

  C++

  ```
  for(int i = 0; i < n; i++) {
      for(int j = 0; j < n; j++) { ... }
  }
  ```

  - *场景：* 冒泡排序、暴力枚举子数组。

- $O(\log N)$ 对数级：

  并没有遍历所有数，而是每次循环让数据规模减半。

  C++

  ```
  while(n > 1) {
      n = n / 2; // 每次砍一半
  }
  ```

  - *场景：* **二分查找** (Binary Search)。**只要看到题目要求 $O(\log N)$，或者数组是有序的，第一反应就是二分。**

- $O(N \log N)$ 线性对数级：

  通常是 $N$ 次循环，每次循环里做一次 $O(\log N)$ 的操作；或者直接调用了高效排序。

  - *场景：* **`std::sort`**（C++ 的 sort 主要是快排+堆排，复杂度是 $N \log N$）、归并排序。



#### 2. 进阶法则：看递归



对于递归函数，**时间复杂度 = 递归次数 $\times$ 每次递归内部的复杂度**。

- **斐波那契数列（暴力递归）：** $O(2^N)$。因为每个节点分裂成 2 个，树深度为 $N$。这是指数级，非常慢。
- **二叉树遍历（DFS）：** $O(N)$。因为每个节点只访问一次。

------



### 第二部分：如何分析空间复杂度 (Space Complexity)



空间复杂度看的是：**除了存储输入数据本身之外，你额外申请了多少内存**（Auxiliary Space）。

1. $O(1)$ 原地工作：

   只定义了 int i, j, ans 这种变量，不随 $N$ 变化。方案三就是典型的 $O(1)$。

2. **$O(N)$ 线性空间**：

   - **显式：** 开了一个 `vector<int> dp(n)` 或者 `map` 来存元素。
   - **隐式（容易忽略）：** **递归调用栈**。比如二叉树的最坏情况（退化成链表），递归深度是 $N$，系统栈空间就是 $O(N)$。

------



### 第三部分：LeetCode 实战“作弊表”（数据规模反推法）



这是刷 Hot 100 最实用的技巧。LeetCode 的 C++ 一般限制运行时间是 **1秒**，大约能执行 **$10^7$ ~ $10^8$ 次** 基本运算。

看题目给出的 $N$ 的范围（Constraints）：

| **N 的规模**     | **允许的最大复杂度**            | **推荐算法思路**                      |
| ---------------- | ------------------------------- | ------------------------------------- |
| $N \le 20$       | $O(2^N)$ 或 $O(N!)$             | 递归回溯（全排列、子集问题）          |
| $N \le 100$      | $O(N^3)$                        | 弗洛伊德算法、三重循环暴力            |
| $N \le 1000$     | $O(N^2)$                        | 动态规划 (DP)、二重循环               |
| **$N \le 10^5$** | **$O(N \log N)$** 或 **$O(N)$** | **最常见！** 排序、二分、双指针、贪心 |
| $N \le 10^6$     | $O(N)$                          | KMP、并查集、线性筛、滑动窗口         |
| $N > 10^9$       | $O(\log N)$ 或 $O(1)$           | 数学方法、二分查找                    |

**应用到 LeetCode 28：**

- 如果题目说 $m, n \le 10^5$，那么你的 $O(m \times n)$ 最坏就是 $10^{10}$，绝对超时。必须用 KMP（$O(m+n)$）。
- 但实际上 LeetCode 28 的测试数据比较弱，且 $n$ 通常较短，所以 $O(mn)$ 也能过。

------

